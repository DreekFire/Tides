{"FileModelVersion":{"Major":1,"Minor":0},"Name":"Projectile Tracking Testing Fortress","Version":16,"SavedTotalBlockCount":945,"SavedMaterialCost":70785.0,"ContainedMaterialCost":548.6111,"ItemDictionary":{"1118":"9411e401-27da-4546-b805-3334f200f055","346":"f29b1372-f4f3-4305-aa85-5fe214361fb7","1116":"8f9dbf41-6c2d-4e7b-855d-b2432c6942a2","347":"26a604f0-071c-49ca-8a0e-e1d9c959b1c5","369":"3ed4d2a4-62ce-4807-b516-6da685804e1e","107":"438b4494-6746-4223-93a1-3a75b08bd5b6","343":"edd65760-896f-4f6a-ba8c-eb2b072635f4","348":"9d2ff3d6-abc2-4378-b47c-cad42d4af1bc","392":"2c557c38-4136-436a-bae2-c5cd1102690c","403":"56c27d46-39b3-4ac1-b4f7-71c118d8dde9","433":"d661f0e7-7f81-4227-80dd-f93aed873630","1067":"e62413c3-e841-4eda-9e2a-ceaec75e8b64","409":"c8fe583a-357b-4fa6-86f1-fc2de639c909","454":"e8d04f75-a134-452e-a04a-af5172d65040","579":"382a7650-2231-4867-96e4-8d97242a4741","1201":"395179c1-37a0-4250-851b-5bc19fd601b6","1200":"049b9d0c-1cb3-4511-be7f-9fad6e0a607e","690":"2e715d3f-349f-41e1-bd89-7f685939d5aa","692":"20100af6-ccd1-41ff-b7b0-5d2f6bb99f85","395":"e6bb2b09-daee-432d-9aff-45fc63d24fca","397":"a56e0dcf-94e4-48a0-b8b9-5e33e0ab69cf","378":"1725c9ed-29fd-438d-97f6-8f645a1865d4","382":"10a165d1-1333-4c57-a942-b857542c4b45","356":"c68d0ed7-66d1-42cd-974e-01aa0f36c847","384":"a6edccd7-3ec8-419c-9405-703e8b4bdc8b","359":"62e2b663-c26f-461e-ae26-43068010f993","374":"1bb2d71d-cd5f-4a23-844b-8005dec7bd5c","387":"3e0a0bd7-7805-4e8f-836e-0cbcfee512af","627":"5031a9db-aa48-4903-9b16-75a54f5959ce","616":"9c09eee2-e4bd-42ea-aaec-43a6d1451db3","625":"139d4b6a-2b6b-4bfa-8d00-1bc8e69923fd","696":"d3924bae-be5a-43a0-be19-64fc7c8d6059","434":"9413049d-a4f7-4c1c-8b8a-d2f1f4c18e53","774":"d5016f16-6431-4e8f-b0cc-5f0f400b151a","795":"91cca4a9-a40f-43eb-9ba5-34c738b03d1f","782":"6ebe5e2b-ef9a-4849-b234-131b25579adf","781":"4b2109f7-abfc-46b7-b752-f9423b6f2e35","794":"6209370e-abeb-4ec1-b523-dc21ea33fe0c","788":"a160804b-15cc-46e2-8ffb-401c2aa01de6","796":"542cacd4-c366-4a76-8d01-4ace6c5ce619","783":"33b65ccc-58a0-487d-8b68-a997a71b0bfe","769":"3bff8428-7481-4847-b00e-f0e49233b86d","785":"99a71734-3128-4535-bb9c-f69de5277f49","431":"5d8870cd-d401-4b52-a3dc-641c02b3b31f","432":"4f87eff7-616b-4663-8f11-cd7a7ddd3649","773":"043e9b00-4a2f-41b8-bf2f-4aaa4442f138","776":"515ee20d-20d8-4195-bea5-213e6f1fd929","772":"267248a3-baaa-4653-83b3-ce478d600b17","793":"e0f9e669-4748-4cde-be95-58e47e094253","770":"819ef76e-1023-4f06-bfb1-96cd3e58ba88","778":"4c24445d-a29b-446e-b03f-29e570e9d47d","775":"01a87958-93cf-4efa-857f-10913b0573d9","787":"da59d582-9254-4091-988e-b670dcabe84a","1117":"649f2aec-6f59-4157-ac01-0122ce2e6dad","810":"310a7a9a-8d4e-4365-a877-1a8e2bac2a81","834":"6222ad4d-f6d8-48c0-9f27-10e2b64d7481","352":"57cd27b4-7876-41a7-8030-d5099d86bc0a","721":"14930ee7-6795-44f4-ab26-a55a67e8ce01","617":"db2a5655-6b32-4877-8285-40c6ddc9ba3c","613":"b6ac5f2e-907e-4926-88c0-355d30c6b7a5","622":"57c4c674-9c66-4ab7-9067-81477824785d","621":"ef2e81c1-d06d-474f-b12c-14de1702db1b","611":"fb1fb4c7-78e8-47e7-8ff1-34a4afcd10c7","650":"45ce64f5-86ca-425a-8074-7603cdfc1d4a","575":"74c982f4-305f-411e-a8b4-d193315ab3bc","591":"c5cec892-2e43-4905-9d28-44fc8ecb5cc7","615":"7dc67bed-fd0f-4145-9525-5840bbcc4822","609":"575187d2-ff5c-4d42-9937-0206cffbd883","610":"9aa6b3c3-2569-473e-9d28-2b2cb17bc7a3","592":"213026bc-fd7a-44e6-b543-a31c219aaef0","678":"a3d914e9-697d-425f-abda-a6b21b4de952"},"Blueprint":{"ContainedMaterialCost":548.6111,"CSI":[0.0,0.0,-1.0,0.0,-1.0,0.0,0.0,9294.865234,0.013986,0.0,0.0,0.0,0.0,82368.607593,35.329369,1.0,1.0,0.0,1.0,3.0,10.0,-1.0,0.0,136500.0,1.0,1.0,135000.0,0.0,0.0,0.0,353.910004,0.0,0.1,0.1,1.0,1.0,3.0,-1.0,0.0,-1.0,35.329369,-1.0,1.0,0.0,-1.0,0.0,0.0,-1.0,134999.993515,135000.0,0.0,780.0,-1.0,2606.200195,0.0,-1.0,108.0,0.0,500.0,-1.0,12.0,0.0,0.0,0.0,10.917339,0.0,0.0,0.0,0.0,0.124854,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,-1.0,-1.0],"COL":["0.011764,0,0,0","1,0,0,0.5","0,1,0,0.5","0,0,1,0.5","0.1,0.1,0.1,0.5","0.3,0.3,0.3,0.5","0.5,0.5,0.5,0.5","1,1,1,0.1","1,1,1,0.5","1,1,1,0.99","1,0.921568,0.015686,0.99","0,1,1,0.99","1,0,1,0.99","0.532304,0.92424,0.976154,0.482858","0.624097,0.172987,0.071987,0.558838","0.589444,0.995137,0.300367,0.102439","0.2717,0.865858,0.367956,0.486776","0.639902,0.591997,0.036744,0.032933","0.775841,0.906789,0.151626,0.255117","0.791803,0.770037,0.042215,0.984062","0.691124,0.827073,0.992751,0.725039","0.308429,0.229756,0.46043,0.078918","0.983768,0.814959,0.334567,0.270744","0.611877,0.542545,0.044901,0.943315","0.88138,0.579203,0.104262,0.074014","0.891141,0.224628,0.060396,0.025437","0.345402,0.253313,0.07177,0.618634","0,0,0,0","1,0.14,0.4,0.8","0.02745,0.83,0.83,0.9","0.01,0,0,0.7","0.84,0.82,0.82,0.8"],"SCs":[{"ContainedMaterialCost":0.0,"CSI":[-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0],"COL":null,"SCs":[],"BLP":["0,0,0","0,1,0","0,1,-1","0,0,-1","0,0,-2","1,0,-2","-1,0,-2","1,0,0","-1,0,0","1,0,1","-1,0,1","1,0,2","-1,0,2","1,0,3","-1,0,3","1,0,4","-1,0,4","1,0,-1","-1,0,-1"],"BLR":[0,16,16,16,16,16,18,16,18,16,18,16,18,16,18,16,18,16,18],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"AAAAKgAAACgAAwAAAAAAAAEAAAAAAAACAAAAABIAdiYAAAAZAEIYAAAAGQBdGwEAABkAAAAEAAAWwwEABAAAFkMGAAEBAQAEzczMPQAABCgAAAABAAVsYXNlcgUAADEAAAAkAAwYAAAAAADsFwAAAAAAAQAAAAAAAAIAAAAAAAB2JgAAAAcAQhgAAAAHAF0bAQAAFQABAAQK1yM8AAAElWdDSAIABJKI/UsAAAQBAAAAAQAFbGFzZXIGAAAxAAAAJAAMGAAAAAAA7BcAAAAAAAEAAAAAAAACAAAAAAAAdiYAAAAHAEIYAAAABwBdGwEAABUAAQAECtcjPAAABD+rdUgCAASHU/1LAAAEAgAAAAEABWxhc2Vy","VehicleData":"8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABXLgAAAAAAAAcAAAAAAAAAAAAAAABHKQEAAAAAABUAAAAAAAAAAAAAAABzJwAAAAAAZAAAAAAAAA==","designChanged":false,"blueprintVersion":0,"blueprintName":"Two Axis Turret","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":592,"LocalPosition":"0,5,11","LocalRotation":"0,0,0,-0.999999","ForceId":0,"TotalBlockCount":19,"MaxCords":"1,1,4","MinCords":"-1,0,-2","BlockIds":[591,625,616,616,616,615,615,609,609,609,609,609,609,609,609,609,609,610,610],"BlockState":"=0,19","AliveCount":19,"BlockStringData":[],"BlockStringDataIds":[],"GameVersion":"4.1.2.0","PersistentSubObjectIndex":7,"PersistentBlockIndex":-1,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"fe5bb7da-f3e9-4d92-acd2-f7002e9544b0","CreatorReadableName":"DreekFire","HashV1":"a5598512ea30c7b3f81210225838b965"},"BlockCount":19},{"ContainedMaterialCost":0.0,"CSI":[-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0],"COL":null,"SCs":[],"BLP":["0,0,0","0,1,0"],"BLR":[0,0],"BP1":null,"BP2":null,"BCI":[0,0],"BEI":null,"BlockData":"AAAAKgAAABwAAwAAAAAAAAEAAAAAAAACAAAAAAAAdiYAAAAHAEIYAAAABwBdGwEAAAcAAQAECtcjPAAABFUAAAABAAtjaGVja1R1cnJldAEAACMAAAA+AAEAAAAAAAACAAAAAB0AAwAAAAAvAF0AAAAANwBdGwEAADcApAAIAAAAAAAAaUClAAgAAAAAAMCiQJgABAUAAAALAAgAAAAAAADwP5gABLAAAAAFAAVjaGVjawAABFYAAAA=","VehicleData":"8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABXLgAAAAAAAAcAAAAAAAAAAAAAAABHKQEAAAAAABUAAAAAAAAAAAAAAABzJwAAAAAAZAAAAAAAAA==","designChanged":false,"blueprintVersion":0,"blueprintName":"Two Axis Turret","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":592,"LocalPosition":"0,5,12","LocalRotation":"0,0,0,1","ForceId":0,"TotalBlockCount":2,"MaxCords":"0,1,0","MinCords":"0,0,0","BlockIds":[591,678],"BlockState":"00","AliveCount":2,"BlockStringData":[],"BlockStringDataIds":[],"GameVersion":"4.1.2.0","PersistentSubObjectIndex":8,"PersistentBlockIndex":-1,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"fe5bb7da-f3e9-4d92-acd2-f7002e9544b0","CreatorReadableName":"DreekFire","HashV1":"a5598512ea30c7b3f81210225838b965"},"BlockCount":2}],"BLP":["0,1,-1","-1,1,-1","1,1,-1","-2,1,-1","2,1,-1","-3,1,-1","3,1,-1","-4,1,-1","4,1,-1","-5,1,-1","5,1,-1","-6,1,-1","6,1,-1","-7,1,-1","7,1,-1","-8,1,-1","8,1,-1","-9,1,-1","9,1,-1","-10,1,-1","10,1,-1","-11,1,-1","11,1,-1","-12,1,-1","12,1,-1","-13,1,-1","13,1,-1","-14,1,-1","14,1,-1","-15,1,-1","15,1,-1","-15,1,-5","15,1,-5","-15,1,-9","15,1,-9","-15,1,-13","15,1,-13","-15,1,-17","15,1,-17","-14,1,-17","14,1,-17","-13,1,-17","13,1,-17","-12,1,-17","12,1,-17","-11,1,-17","11,1,-17","-10,1,-17","10,1,-17","-9,1,-17","9,1,-17","-8,1,-17","8,1,-17","-7,1,-17","7,1,-17","-6,1,-17","6,1,-17","-5,1,-17","5,1,-17","-4,1,-17","4,1,-17","-3,1,-17","3,1,-17","-2,1,-17","2,1,-17","-1,1,-17","1,1,-17","0,1,-17","-15,1,3","15,1,3","-15,1,7","15,1,7","-15,1,11","15,1,11","-15,1,15","15,1,15","-14,1,15","14,1,15","-13,1,15","13,1,15","-12,1,15","12,1,15","-11,1,15","11,1,15","-10,1,15","10,1,15","-9,1,15","9,1,15","-8,1,15","8,1,15","-7,1,15","7,1,15","-6,1,15","6,1,15","-5,1,15","5,1,15","-4,1,15","4,1,15","-3,1,15","3,1,15","-2,1,15","2,1,15","-1,1,15","1,1,15","0,1,15","1,1,11","2,1,11","0,1,11","3,1,11","-1,1,11","4,1,11","-2,1,11","1,1,7","5,1,11","-3,1,11","2,1,7","0,1,7","6,1,11","-4,1,11","3,1,7","-1,1,7","7,1,11","-5,1,11","4,1,7","-2,1,7","8,1,11","-6,1,11","1,1,3","5,1,7","-3,1,7","9,1,11","-7,1,11","2,1,3","0,1,3","6,1,7","-4,1,7","10,1,11","-8,1,11","3,1,3","-1,1,3","7,1,7","-5,1,7","11,1,11","-9,1,11","4,1,3","-2,1,3","8,1,7","-6,1,7","12,1,11","-10,1,11","5,1,3","-3,1,3","9,1,7","-7,1,7","13,1,11","-11,1,11","6,1,3","-4,1,3","10,1,7","-8,1,7","14,1,11","-12,1,11","7,1,3","-5,1,3","11,1,7","-9,1,7","-13,1,11","8,1,3","-6,1,3","12,1,7","-10,1,7","-14,1,11","9,1,3","-7,1,3","13,1,7","-11,1,7","10,1,3","-8,1,3","14,1,7","-12,1,7","11,1,3","-9,1,3","-13,1,7","12,1,3","-10,1,3","-14,1,7","13,1,3","-11,1,3","14,1,3","-12,1,3","-13,1,3","-14,1,3","1,1,-5","2,1,-5","0,1,-5","3,1,-5","-1,1,-5","4,1,-5","-2,1,-5","1,1,-9","5,1,-5","-3,1,-5","2,1,-9","0,1,-9","6,1,-5","-4,1,-5","3,1,-9","-1,1,-9","7,1,-5","-5,1,-5","4,1,-9","-2,1,-9","8,1,-5","-6,1,-5","1,1,-13","5,1,-9","-3,1,-9","9,1,-5","-7,1,-5","2,1,-13","0,1,-13","6,1,-9","-4,1,-9","10,1,-5","-8,1,-5","3,1,-13","-1,1,-13","7,1,-9","-5,1,-9","11,1,-5","-9,1,-5","4,1,-13","-2,1,-13","8,1,-9","-6,1,-9","12,1,-5","-10,1,-5","5,1,-13","-3,1,-13","9,1,-9","-7,1,-9","13,1,-5","-11,1,-5","6,1,-13","-4,1,-13","10,1,-9","-8,1,-9","14,1,-5","-12,1,-5","7,1,-13","-5,1,-13","11,1,-9","-9,1,-9","-13,1,-5","8,1,-13","-6,1,-13","12,1,-9","-10,1,-9","-14,1,-5","9,1,-13","-7,1,-13","13,1,-9","-11,1,-9","10,1,-13","-8,1,-13","14,1,-9","-12,1,-9","11,1,-13","-9,1,-13","-13,1,-9","12,1,-13","-10,1,-13","-14,1,-9","13,1,-13","-11,1,-13","14,1,-13","-12,1,-13","-13,1,-13","-14,1,-13","0,2,-17","0,8,-17","0,6,-17","0,2,-16","0,2,-15","0,2,-14","0,2,-13","0,2,-12","0,3,-12","0,3,-13","0,3,-14","1,2,-16","1,2,-15","1,2,-14","1,2,-13","1,2,-12","-1,2,-12","-1,2,-13","-1,2,-14","-1,2,-15","-1,2,-16","-2,3,-16","-2,3,-15","-2,3,-14","-2,3,-13","-2,3,-12","2,3,-12","2,3,-13","2,3,-14","2,3,-15","2,3,-16","1,3,-12","1,3,-13","1,3,-14","1,3,-15","1,3,-16","-1,3,-16","-1,3,-15","-1,3,-14","-1,3,-13","-1,3,-12","-2,2,-16","-2,2,-15","-2,2,-14","-2,2,-13","-2,2,-12","-2,2,-11","2,2,-11","2,2,-12","2,2,-13","2,2,-14","2,2,-15","2,2,-16","4,2,-13","-4,2,-13","2,3,-11","1,3,-11","0,3,-11","-1,3,-11","-2,3,-11","0,2,-11","-1,2,-11","1,2,-11","0,4,-15","0,4,-12","-2,4,-16","2,4,-16","-2,4,-14","2,4,-14","-2,4,-12","2,4,-12","0,3,-16","7,2,-12","-7,2,-12","7,2,-15","-7,2,-15","-15,0,-17","15,0,-17","-14,0,-17","14,0,-17","-14,0,-16","14,0,-16","-15,0,-16","15,0,-16","-14,0,18","14,0,18","-15,0,18","15,0,18","-14,0,17","14,0,17","-15,0,17","15,0,17","-1,5,-16","1,5,-16","-5,5,-16","5,5,-16","-5,5,-15","5,5,-15","-5,5,-14","5,5,-14","-5,5,-13","5,5,-13","-5,5,-12","5,5,-12","-5,5,-11","5,5,-11","-1,5,-11","1,5,-11","-1,5,-12","1,5,-12","-1,5,-13","1,5,-13","-1,5,-14","1,5,-14","-1,5,-15","1,5,-15","0,5,-16","0,5,-13","0,2,-10","-1,2,-10","1,2,-10","-2,2,-10","2,2,-10","-3,2,-10","3,2,-10","-4,2,-10","4,2,-10","-5,2,-10","5,2,-10","-6,2,-10","6,2,-10","-7,2,-10","7,2,-10","-8,2,-10","8,2,-10","-9,2,-10","9,2,-10","-9,2,-11","9,2,-11","-9,2,-12","9,2,-12","-9,2,-13","9,2,-13","-9,2,-14","9,2,-14","-9,2,-15","9,2,-15","-9,2,-16","9,2,-16","-9,2,-17","9,2,-17","-8,2,-17","8,2,-17","-7,2,-17","7,2,-17","-6,2,-17","6,2,-17","-5,2,-17","5,2,-17","-4,2,-17","4,2,-17","-3,2,-17","3,2,-17","-2,2,-17","2,2,-17","-1,2,-17","1,2,-17","0,2,-9","0,2,-7","0,8,-18","0,3,-15","0,9,-17","-10,5,-17","10,5,-17","-10,5,-10","10,5,-10","-9,5,-9","9,5,-9","-9,5,-18","9,5,-18","-1,9,-17","1,9,-17","0,10,-17","1,8,-17","-1,8,-17","0,9,-16","0,8,-16","0,3,11","-1,3,11","1,3,11","0,2,11","0,4,10","0,2,-8","-2,-4,-17","-2,-4,-13","-2,-4,-9","-2,-3,-16","-2,-3,-14","-2,-3,-13","-2,-3,-11","-2,-3,-9","-2,-2,-17","-2,-2,-16","-2,-2,-15","-2,-2,-14","-2,-2,-13","-2,-2,-12","-2,-2,-11","-2,-2,-10","-2,-2,-9","-2,-1,-16","-2,-1,-14","-2,-1,-13","-2,-1,-11","-2,-1,-9","-2,0,-17","-2,0,-16","-2,0,-15","-2,0,-13","-2,0,-9","-1,-4,-16","-1,-4,-14","-1,-4,-13","-1,-4,-11","-1,-4,-9","-1,-3,-17","-1,-3,-16","-1,-3,-15","-1,-3,-14","-1,-3,-12","-1,-3,-11","-1,-3,-10","-1,-2,-17","-1,-2,-16","-1,-2,-15","-1,-2,-14","-1,-2,-13","-1,-2,-12","-1,-2,-11","-1,-2,-10","-1,-2,-9","-1,-1,-17","-1,-1,-16","-1,-1,-15","-1,-1,-14","-1,-1,-12","-1,-1,-11","-1,-1,-10","-1,0,-16","-1,0,-14","-1,0,-13","-1,0,-11","0,-4,-17","0,-4,-16","0,-4,-15","0,-4,-14","0,-4,-13","0,-4,-12","0,-4,-11","0,-4,-10","0,-4,-9","0,-3,-17","0,-3,-16","0,-3,-15","0,-3,-14","0,-3,-13","0,-3,-12","0,-3,-11","0,-3,-10","0,-3,-9","0,-2,-17","0,-2,-16","0,-2,-15","0,-2,-14","0,-2,-13","0,-2,-12","0,-2,-11","0,-2,-10","0,-2,-9","0,-1,-17","0,-1,-16","0,-1,-15","0,-1,-14","0,-1,-13","0,-1,-12","0,-1,-11","0,-1,-10","0,-1,-9","0,0,-17","0,0,-16","0,0,-15","0,0,-14","0,0,-13","0,0,-12","0,0,-11","0,0,-10","0,0,-9","1,-4,-16","1,-4,-14","1,-4,-13","1,-4,-11","1,-3,-17","1,-3,-16","1,-3,-15","1,-3,-14","1,-3,-12","1,-3,-11","1,-3,-10","1,-2,-17","1,-2,-16","1,-2,-15","1,-2,-14","1,-2,-13","1,-2,-12","1,-2,-11","1,-2,-10","1,-2,-9","1,-1,-17","1,-1,-16","1,-1,-15","1,-1,-14","1,-1,-12","1,-1,-11","1,-1,-10","1,0,-16","1,0,-14","1,0,-13","1,0,-11","1,0,-9","2,-4,-17","2,-4,-16","2,-4,-15","2,-4,-13","2,-4,-9","2,-3,-16","2,-3,-14","2,-3,-13","2,-3,-11","2,-3,-9","2,-2,-17","2,-2,-16","2,-2,-15","2,-2,-14","2,-2,-13","2,-2,-12","2,-2,-11","2,-2,-10","2,-2,-9","2,-1,-16","2,-1,-14","2,-1,-13","2,-1,-11","2,-1,-9","2,0,-17","2,0,-13","2,0,-9","-3,-4,-17","3,-4,-17","-3,-4,-9","3,-4,-9","-3,-4,-12","3,-4,-12","-3,-4,-14","3,-4,-14","-3,0,-17","3,0,-17","-3,0,-12","3,0,-12","0,6,-10","-2,6,-10","2,6,-10","-4,6,-10","4,6,-10","-4,6,-11","4,6,-11","-2,6,-11","2,6,-11","0,6,-11","0,7,-11","-2,7,-11","2,7,-11","-4,7,-11","4,7,-11","0,2,12","9,6,-17","-9,6,-17","9,7,-17","-9,7,-17","0,9,-18","1,9,-18","34,6,-17","-34,6,-17","34,7,-17","-34,7,-17","15,2,-16","-15,2,-16","10,6,-17","-10,6,-17","14,6,-17","-14,6,-17","18,6,-17","-18,6,-17","22,6,-17","-22,6,-17","26,6,-17","-26,6,-17","30,6,-17","-30,6,-17","34,6,-18","-34,6,-18","2,3,11","-2,3,11","2,3,10","-2,3,10","2,3,9","-2,3,9","2,3,8","-2,3,8","2,3,7","-2,3,7","2,3,6","-2,3,6","2,3,5","-2,3,5","2,3,4","-2,3,4","2,3,3","-2,3,3","2,3,2","-2,3,2","1,3,2","-1,3,2","1,3,3","-1,3,3","1,3,4","-1,3,4","1,3,5","-1,3,5","1,3,6","-1,3,6","1,3,7","-1,3,7","1,3,8","-1,3,8","1,3,9","-1,3,9","2,2,2","-2,2,2","2,2,3","-2,2,3","2,2,4","-2,2,4","2,2,5","-2,2,5","2,2,6","-2,2,6","2,2,7","-2,2,7","2,2,8","-2,2,8","2,2,9","-2,2,9","2,3,-5","-2,3,-5","2,3,-4","-2,3,-4","2,3,-3","-2,3,-3","2,3,-2","-2,3,-2","2,4,2","-2,4,2","2,4,3","-2,4,3","2,4,4","-2,4,4","2,4,5","-2,4,5","2,4,6","-2,4,6","2,4,7","-2,4,7","2,4,8","-2,4,8","2,4,9","-2,4,9","3,3,2","-3,3,2","3,3,3","-3,3,3","3,3,4","-3,3,4","3,3,5","-3,3,5","3,3,6","-3,3,6","3,3,7","-3,3,7","3,3,8","-3,3,8","3,3,9","-3,3,9","4,3,2","-4,3,2","4,3,3","-4,3,3","4,3,4","-4,3,4","4,3,5","-4,3,5","4,3,6","-4,3,6","4,3,7","-4,3,7","4,3,8","-4,3,8","4,3,9","-4,3,9","5,2,2","-5,2,2","5,2,3","-5,2,3","5,2,4","-5,2,4","5,2,5","-5,2,5","5,2,6","-5,2,6","5,2,7","-5,2,7","5,2,8","-5,2,8","5,2,9","-5,2,9","5,3,-5","-5,3,-5","5,3,-4","-5,3,-4","5,3,-3","-5,3,-3","5,3,-2","-5,3,-2","5,3,-1","-5,3,-1","5,3,0","-5,3,0","5,3,2","-5,3,2","5,3,3","-5,3,3","5,3,4","-5,3,4","5,3,5","-5,3,5","5,3,6","-5,3,6","5,3,7","-5,3,7","5,3,8","-5,3,8","5,3,9","-5,3,9","5,3,10","-5,3,10","5,4,2","-5,4,2","5,4,3","-5,4,3","5,4,4","-5,4,4","5,4,5","-5,4,5","5,4,6","-5,4,6","5,4,7","-5,4,7","5,4,8","-5,4,8","5,4,9","-5,4,9","6,3,2","-6,3,2","6,3,3","-6,3,3","6,3,4","-6,3,4","6,3,5","-6,3,5","6,3,6","-6,3,6","6,3,7","-6,3,7","6,3,8","-6,3,8","6,3,9","-6,3,9","2,3,-1","-2,3,-1","2,3,0","-2,3,0","-3,3,1","3,3,1","-2,2,1","2,2,1","-2,3,-6","2,3,-6","-2,3,1","2,3,1","-2,4,1","2,4,1","-1,3,1","1,3,1","-6,3,1","6,3,1","-5,2,1","5,2,1","-5,3,-6","5,3,-6","-5,3,1","5,3,1","-5,4,1","5,4,1","-4,3,1","4,3,1","-3,3,11","3,3,11","-4,3,11","4,3,11","-5,3,11","5,3,11","0,6,-13","2,6,-13","4,6,-13","-2,6,-13","-4,6,-13","-2,6,-14","-4,6,-14","0,6,-14","2,6,-14","4,6,-14","4,7,-14","2,7,-14","0,7,-14","-2,7,-14","-4,7,-14"],"BLR":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,10,0,0,0,0,0,6,6,6,23,23,23,23,23,20,20,20,20,20,0,0,0,0,0,0,0,0,0,0,22,22,22,22,22,21,21,21,21,21,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,0,0,9,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,0,0,6,2,0,21,20,21,20,16,18,19,17,11,9,1,16,18,20,20,0,0,0,11,0,0,0,0,13,22,19,18,20,7,1,13,9,20,22,5,15,9,1,16,19,18,20,1,0,7,0,0,1,10,14,12,8,13,22,12,18,18,12,14,12,6,18,18,17,12,18,2,18,2,22,0,18,18,2,2,2,3,2,0,4,9,6,8,12,10,1,8,3,15,6,10,12,12,16,14,4,14,19,0,0,0,0,0,0,0,0,18,10,6,0,12,18,2,9,2,17,7,10,15,10,6,15,7,13,1,0,14,12,8,22,12,16,16,12,14,12,6,18,16,19,0,17,2,17,14,22,0,16,16,2,2,2,6,2,0,4,20,0,9,12,12,15,18,17,16,21,1,15,23,11,21,16,11,15,7,8,23,17,16,21,8,0,0,5,10,10,10,10,10,10,10,10,0,0,0,0,0,0,0,0,0,16,18,16,18,16,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,9,9,1,3,1,3,1,3,1,3,1,3,1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,20,21,20,21,20,21,20,21,20,21,20,21,20,21,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,0,0,0,0,0,0,0,0,7,5,7,5,5,7,7,5,7,5,7,5,7,5,7,5,23,22,23,22,23,22,23,22,23,22,23,22,23,22,23,22,20,21,20,21,20,21,20,21,20,21,20,21,20,21,20,21,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,5,7,5,5,7,7,5,7,5,7,5,7,5,7,5,23,22,23,22,23,22,23,22,23,22,23,22,23,22,23,22,0,0,0,0,20,21,9,11,0,0,0,0,7,5,23,22,20,21,9,11,0,0,0,0,7,5,23,22,0,0,0,0,0,0,0,0,0,0,0,16,16,16,16,16,0,0,0,0,0],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"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","VehicleData":"8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABXLgAAAAAAAAcAAAAAAAAAAAAAAABHKQEAAAAAABUAAAAAAAAAAAAAAABzJwAAAAAAZAAAAAAAAD41FAAAAAAABwAAACMAAQAAAAAAAAoABM3MzD0LAATNzMw9DAAEzczMPQ0ABM3MzD0OAATNzMw9UkMAAAAAAAAHAAAAAAABAAAAAAAAwX1WnwAAAAAHAAAABwAAAAAAAAAAAAAEAQAAAMRKAAAAAAAABwAAABwAAAAAAAAAAAAABA2C4kgBAATGaeVDAgAEOLV9TAMABKxppUc57QcAAAAAAAcAAAAAAAEAAAAAAAAr3goAAAAAAAcAAAAIAAEAAAAAAAAAAAEAAQABANCrZQAAAAAADgAAAAsAAAAAAAAAAAEAAAAACwADAAEBEQAEAQAAAMInYQAAAAAABwAAAEYAAAAAAAAAAAAABAAASEIKAAQAAMjBDwAEAABcQhQABAAA+kMZAAQAgDtFMgAEAEAcRjcABABAHEYeAAQAAIA/IwAEAACAPygABAAAoEEyjlAAAAAAAAcAAAAAAAAAAAAAAAAuywQAAAAAAAcAAAAAACSIAAAAAAAS6AEAAAAAAA4AAAAAAA8nAAAAAACghgEAAAAAoflWAAAAAAAOAAAAAAAPJwAAAAAAoGNvAAAAAA==","designChanged":false,"blueprintVersion":16,"blueprintName":"Projectile Tracking Testing Fortress","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":575,"LocalPosition":"10035.11,4.834379,10067.12","LocalRotation":"0,-0.6637976,0,0.7479123","ForceId":272834106,"TotalBlockCount":945,"MaxCords":"34,10,18","MinCords":"-34,-4,-18","BlockIds":[1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,346,1116,347,346,346,346,346,369,369,369,369,369,369,369,369,369,369,369,369,369,346,346,346,346,346,346,346,346,346,346,369,369,369,369,369,369,369,369,369,369,369,369,369,369,369,369,369,369,369,369,369,369,107,107,346,346,346,346,346,343,348,392,403,433,1067,1067,1067,1067,1067,1067,409,454,454,454,454,579,579,579,579,579,579,579,579,579,579,579,579,579,579,579,579,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1201,1200,1200,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,690,692,395,397,346,378,378,378,378,378,378,378,378,382,382,356,384,359,374,387,627,616,616,625,1116,696,434,434,774,795,782,781,794,788,795,796,783,769,769,783,796,783,785,783,781,782,795,431,431,774,432,434,432,794,781,782,795,788,773,776,773,776,773,776,773,776,772,776,769,794,776,772,776,794,773,776,773,776,773,776,773,793,782,781,794,794,796,774,783,769,783,770,783,785,776,772,776,772,794,776,770,776,794,778,775,775,775,775,775,775,775,787,776,772,776,772,794,776,770,776,794,794,796,783,783,769,783,770,783,785,783,782,781,794,773,776,773,776,773,776,773,776,772,776,769,794,776,772,776,794,773,776,773,776,773,776,773,794,781,782,795,788,431,774,432,434,432,783,781,782,795,431,795,796,783,769,769,783,796,783,785,795,782,781,794,788,434,434,774,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,347,347,347,347,347,343,343,343,343,343,348,348,348,348,348,1117,810,810,834,834,343,352,810,810,834,834,378,378,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,1118,721,721,616,616,617,617,613,613,613,613,613,613,613,613,613,613,613,613,613,613,613,613,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,621,621,621,621,621,621,621,621,621,621,621,621,621,621,621,621,611,611,611,611,611,611,650,650,621,621,621,621,621,621,621,621,621,621,621,621,621,621,621,621,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,621,621,621,621,621,621,621,621,621,621,621,621,621,621,621,621,611,611,611,611,611,611,650,650,650,650,650,650,613,613,613,613,613,613,613,613,613,613,613,613,613,613,613,613,617,617,621,621,621,621,621,621,621,621,621,621,621,621,621,621,621,621,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,622,650,650,650,650,622,622,621,621,611,611,613,613,621,621,622,622,622,622,621,621,611,611,613,613,621,621,622,622,616,616,616,616,616,616,347,347,347,347,347,343,343,343,343,343,348,348,348,348,348],"BlockState":"=0,924","AliveCount":924,"BlockStringData":["  -- Settings\r\n  -- Each redundant Lua box should have a unique, positive luaIdx (i.e. 1, 2, 3, ...). They will come online if all lower index Lua boxes are destroyed.\r\n  local luaIdx = 1\r\n\r\n  -- use pCall to avoid crash, retry if failed\r\n  local AllowErrorRecovery = false\r\n\r\n  -- scaling for axes in projectile avoidance routine used to detect projectiles\r\n    -- projectile avoidance should output value / scale into A, B, and D axes\r\n  local altScale = 800\r\n  local bearScale = 180\r\n  local distScale = 800\r\n\r\n  -- seconds to record target movements for\r\n  local targetTrackTime = 15\r\n  -- number of locations to track per enemy (todo: support tracking multiple projectiles simultaneously)\r\n  local numOrigins = 3\r\n  -- time between switching targets\r\n  local originSwitchTime = 2\r\n  -- maximum time to remember origin points\r\n  local maxStaleness = 6\r\n  -- altitudes to engage (estimated altitude of firing piece, not target position)\r\n    -- checked when adding an origin\r\n  local minAlt = 0\r\n  local maxAlt = math.huge\r\n  -- parameters to find weapons (Shift+N to name turret blocks)\r\n    -- different turrets should have different names even if they have the same weapon\r\n    -- both turrets and firing pieces should be named\r\n    -- firing pieces can share the name of the turret they are mounted on\r\n    -- if weapons on the same turret have different muzzle velocities, name them differently from each other\r\n      -- only one should have the same name as the turret, usually the one with the narrowest aiming arc\r\n  local weaponDef = {\r\n    {\r\n      name = \"laser\",\r\n      -- Normally reads muzzle velocity from weapon info. Set a value here to override it, i.e. if you have multiple firing pieces on the same turret\r\n      -- velocity = math.huge,\r\n      minRange = 50,\r\n      maxRange = 2000,\r\n      -- per-weapon altitude settings checked when firing, not when adding origins\r\n      minAlt = 0,\r\n      maxAlt = math.huge,\r\n    }\r\n  }\r\n  -- checkACB lists ACBs set to detect object presence and trigger custom axis\r\n    -- will be checked before firing to make sure blocks actually exist at target distance\r\n    -- this check is not performed when firing at aimpoint due to idle mode \"fire\" or \"timer\"\r\n    -- may also have second ACB with inverted settings that trigger negative custom axis, in which case set inverted to true\r\n  local checkACBs = {\r\n    { axis = \"check\", minRange = 200, maxRange = 2400, turretName = \"checkTurret\", offset = Vector3(0, 1, 0), inverted = false },\r\n  }\r\n  -- checkACBRequire is required ratio of sum of axis values to number of valid ACBs \r\n  local checkACBRequire = 1\r\n  -- validACBRequire is required number of ACBs in range and pointing in the right direction\r\n  local validACBRequire = 0\r\n\r\n  -- custom axis containing stability value (need breadboard to get this value)\r\n  local stabilityAxisName = \"Stability\"\r\n  -- will fire if any are true, set to 0 to ignore\r\n  -- will fire if stability exceeds this value\r\n  local minStabilityToFire = 0\r\n  -- will fire if stability exceeds the average stability\r\n    -- calculated by an exponential filter with time constant of stabilityAvgTime\r\n  local stabilityAvgTime = 3\r\n  -- will fire if stability is the highest its been in this many seconds\r\n  local stabilityMaxTime = 1\r\n\r\n  -- indexes of mainframes to be used to track enemy rotations\r\n    -- 3 is the bare minimum, but will fail if any of them target a subconstruct\r\n    -- so more is preferred\r\n    -- it will also fail if too many mainframes switch their aimpoint simultaneously\r\n    -- this is unavoidable in the case of blocks being destroyed, but can be avoided\r\n    -- in the case of the timer switching blocks.\r\n\r\n  -- todo: track aimpoint switching time\r\n    -- invalidate track if aimpoint switching time has passed\r\n    -- if aimpoint switching time set to allow script to control it,\r\n      -- adjust switching time to avoid multiple mainframes switching at once\r\n  local aimPointTrackers = {\r\n    { idx = 0 },\r\n    { idx = 1 },\r\n    { idx = 2 },\r\n    { idx = 3 },\r\n    { idx = 4 },\r\n    { idx = 5 },\r\n  }\r\n  -- which mainframe to use, will affect target prioritization\r\n    -- currently only fires at the highest priority target\r\n    -- can be the same as one of the aimPointTrackers\r\n  local mainframeIdx = 0\r\n  -- what to do when no firing origin detected\r\n    -- timer: wait for waitTime seconds, then fire at current target if no origin found\r\n    -- fire: aim and fire at current target\r\n    -- enemy: aim at current target\r\n    -- none: return to idle position\r\n    -- last: continue aiming at last absolute bearing\r\n  local idleAim = \"timer\"\r\n  -- time to wait for a new origin before firing at the aimpoint\r\n    -- only used in idle aim mode \"timer\"\r\n  local waitTime = 10\r\n  -- offset the aimpoint, i.e. for hitting the necks, tetris, or turret bases instead of the barrels\r\n    -- is a function with the following properties:\r\n    --[[\r\n      Arguments:\r\n        origin - if isCounter is true, then the original origin, a table containing:\r\n            position - position of firing point relative to enemy position\r\n            time - estimated time at which projectile was fired,\r\n            relVel - velocity of projectile relative to enemy at firing time,\r\n            detectPos - position at which the projectile was detected,\r\n            detectTime - the time at which the projectile was detected\r\n            type - 0 for APS, 1 for CRAM, 2 for missile\r\n          otherwise just the aimpoint position relative to the enemy position\r\n        targetPos - the target position\r\n        targetVel - the target velocity\r\n        targetRot - the target rotation relative to when the target was first detected\r\n        isCounter - whether we are firing at an origin detected by the counterbattery script or just the AI aimpoint\r\n      Returns:\r\n        fpOffset - the offset of the adjusted aimpoint relative to the original aimpoint\r\n    ]]\r\n    -- to adjust depending on estimated turret location\r\n  -- todo: return list of locations to attempt, using the checkACBs to check each one\r\n  local function aimOffset(origin, targetPos, targetVel, targetRot, isCounter)\r\n    return Vector3.zero\r\n    -- example: against APS, try to break tetris, against CRAM, try to hit firing piece (assumes barrel is about 8m long)\r\n    --  against AI aimpoint or missile launcher, does not modify aimpoint\r\n    -- if isCounter then\r\n    --   local ofs = Vector3.zero\r\n    --   if origin.type == 0 then\r\n    --     ofs = Vector3(0, -7, 0)\r\n    --   elseif origin.type == 1 then\r\n    --     local rot = targetRot * Quaternion.Inverse(origin.rot)\r\n    --     ofs = -8 * (rot * origin.relVel.normalized)\r\n    --     ofs.y = ofs.y - 1.5\r\n    --   end\r\n    --   ofs.y = math.max(ofs.y, minAlt - (targetPos.y + origin.position.y) + 0.1)\r\n    --   return ofs\r\n    -- end\r\n    -- return Vector3.zero\r\n  end\r\n  -- when tracking rotation, reject any rotation estimates above this rate (in deg/s)\r\n  local maxTurnRateTracking = 720\r\n  -- whether or not to attempt to snipe missile launchers\r\n    -- since missiles can turn, we can't trace back their trajectory\r\n    -- however, if we detect a missile the instant it is launched (most feasible for huge missiles\r\n      -- and large missiles with low ramp time, no ignition delay, and high thrust),\r\n    -- we can approximate the missile as traveling in a straight line\r\n  local missileCounter = true\r\n  -- uses assumptions of 240/285/300m/s initial velocity and conservation of energy\r\n    -- to more accurately determine CRAM launch point\r\n    -- only reliable with automatic detection.\r\n  local cramCounter = false\r\n  -- degrees of inaccuracy allowed for ACB object checking\r\n    -- NOT used for firing weapons because weaponInfo.CurrentDirection is not accurate\r\n  local AIM_TOL = 0.1\r\n  -- physics ticks per second (Lua runs in sync with game physics)\r\n  local TICKS_PER_S = 40\r\n\r\n  -- todo: Integrate with enemy identififcation script to get weapon distances from origin,\r\n    -- and trace to that distance from origin instead of closest\r\n  -- todo: Account for target acceleration\r\n\r\n  -- Stored Variables\r\n  -- one way to store previous values is in local variables outside of Update like this\r\n    -- another way is to use global variables, which has the benefit of being able to be\r\n    -- located near where they are used, but are much slower to access (requires a table lookup)\r\n  local inited = false\r\n\r\n  local continueLine = false\r\n  local currentLine = {}\r\n  local currentTargetId\r\n  local enemies = {}\r\n  local foundMissiles = {}\r\n  local frameTime\r\n  local lastAim\r\n  local lastFrameTime\r\n  local lastOrigin\r\n  local lastOriginSwitchTime = 0\r\n  local lastProjectilePos\r\n  local nextRecordTime\r\n  local originPopTime = 0\r\n  local prevTime\r\n  local stabilityAvg = 1\r\n  local stabilityWindow\r\n  local t\r\n  local trackLossTime = 0\r\n  local turrets = {}\r\n\r\n  -- Tides header\r\n  local BlockUtil = {}\r\n  local Combat = {}\r\n  local StringUtil = {}\r\n  local Accumulator = {}\r\n  local Differ = {}\r\n  local Graph = {}\r\n  local Heapq = {}\r\n  local LinkedList = {}\r\n  local MathUtil = {}\r\n  local Matrix3 = {}\r\n  local RingBuffer = {}\r\n  local Search = {}\r\n  local Stats = {}\r\n  local VectorN = {}\r\n  local Control = {}\r\n  local Nav = {}\r\n  local Scheduling = {}\r\n  local Targeting = {}\r\n\r\n  function Init(I)\r\n    for idx, weapon in ipairs(weaponDef) do\r\n      turrets[idx] = BlockUtil.getWeaponsByName(I, weapon.name)\r\n    end\r\n\r\n    for acbIdx, acb in ipairs(checkACBs) do\r\n      acb.turretSub = BlockUtil.getSubConstructsByName(I, acb.turretName, 1)[1]\r\n      acb.turret = BlockUtil.getWeaponsByName(I, acb.turretName, 1)[1]\r\n    end\r\n\r\n    nextRecordTime = I:GetTimeSinceSpawn()\r\n    if stabilityMaxTime > 0 then\r\n      stabilityWindow = LinkedList.LinkedList()\r\n    end\r\n    math.randomseed(I:GetTime())\r\n    math.random()\r\n    math.random()\r\n\r\n    originPopTime = I:GetTimeSinceSpawn()\r\n    inited = true\r\n  end\r\n\r\n  function Update(I)\r\n    -- I:ClearLogs()\r\n    if AllowErrorRecovery then\r\n      ProtectedUpdate(I)\r\n    else\r\n      CoreUpdate(I)\r\n    end\r\n  end\r\n\r\n  function ProtectedUpdate(I)\r\n    local updateRan, err = pcall(CoreUpdate, I)\r\n    if not updateRan then\r\n      I:Log(\"Error in Update\")\r\n      I:Log(err)\r\n      return false -- This means we had an error, so just move on in the LUA.\r\n    else\r\n      I:Log(\"Ran update\")\r\n    end\r\n  end\r\n\r\n  function CoreUpdate(I)\r\n    if not inited then\r\n      Init(I)\r\n    end\r\n    -- Redundant Lua system. Prevents this box from running until higher priority boxes have all been destroyed.\r\n    I:RequestCustomAxis(\"luaActive\", 2 ^ (-luaIdx))\r\n    if I:GetCustomAxis(\"luaActive\") > 2 ^ (1 - luaIdx) then\r\n        return\r\n    end\r\n    t = I:GetTimeSinceSpawn()\r\n    frameTime = lastFrameTime and t - lastFrameTime or 0\r\n    lastFrameTime = t\r\n\r\n    local target = I:GetTargetInfo(mainframeIdx, 0)\r\n    if not target or not target.Valid then\r\n      return\r\n    end\r\n\r\n    if t >= nextRecordTime - 0.5 / TICKS_PER_S then\r\n      UpdateEnemyData(I)\r\n      local stability = I:GetCustomAxis(stabilityAxisName)\r\n      if stability then\r\n        CheckStability(stability)\r\n      end\r\n      nextRecordTime = nextRecordTime + 1 / TICKS_PER_S\r\n    end\r\n    currentTargetId = target.Id\r\n\r\n    local enemy = enemies[currentTargetId]\r\n    if not enemy then return end\r\n\r\n    local alt = altScale * I:GetPropulsionRequest(9) -- A axis, set in projectile avoidance routine\r\n    local relBear = bearScale * I:GetPropulsionRequest(10) -- B axis (is this guaranteed to be -180 to 180?)\r\n    local dist = distScale * I:GetPropulsionRequest(12) -- D axis (maybe increase to account for large/huge missiles)\r\n    local projectile = GetProjectile(I, alt, relBear, dist)\r\n\r\n    if not projectile then\r\n      currentLine = {}\r\n      lastProjectilePos = nil\r\n    end\r\n\r\n    if missileCounter then\r\n      local origins = GetMissileOrigin(I, enemy)\r\n      if origins then\r\n        for i, origin in ipairs(origins) do\r\n          RingBuffer.push(enemies[target.Id].origins, origin)\r\n        end\r\n      end\r\n    end\r\n\r\n    -- compare to past projectile locations\r\n    -- to make sure we're tracking the same projectile\r\n\r\n    -- see if it matches current line\r\n    -- todo: store multiple lines and find match\r\n\r\n    -- 2/3rds the estimated drop in two frames due to gravity\r\n    -- inconsistent with theoretical formula due to discrete integration\r\n    -- powered missiles have no gravity so their expected error\r\n    -- is the negative of the drop due to gravity\r\n    local eps = 10 * frameTime * frameTime\r\n    -- todo: maybe limit how often the line tracing runs to save processing power\r\n    if lastProjectilePos and CheckAndUpdateLine(I, currentLine, projectile, eps) then\r\n      if not continueLine then\r\n        local origin = GetOrigin(I, currentLine, enemy)\r\n        if origin then\r\n          RingBuffer.push(enemy.origins, origin)\r\n        end\r\n      end\r\n      continueLine = true\r\n    else\r\n      -- todo: maybe get origin again when line ends. Not necessary currently since munition detection is perfect\r\n      continueLine = false\r\n    end\r\n\r\n    lastProjectilePos = projectile\r\n\r\n    -- fire weapon at origins\r\n    if I:GetAIFiringMode(mainframeIdx) == \"off\" then return end\r\n    local origin\r\n    if lastOriginSwitchTime + originSwitchTime > t then\r\n      origin = lastOrigin\r\n    end\r\n    if not origin then\r\n      origin = PickTargetOrigin(I, enemy)\r\n      lastOriginSwitchTime = t\r\n      lastOrigin = origin\r\n    end\r\n\r\n    local fp\r\n    local eRot = enemy.rotation[enemy.rotation.size] or Quaternion.identity\r\n    if origin then\r\n      I:Log(\"Aiming at origin, type \"..origin.type)\r\n      fp = eRot * origin.position + aimOffset(origin, target.Position, target.Velocity, eRot, true)\r\n      local acbPass = PerformACBCheck(I, fp, target)\r\n      if not acbPass then\r\n        origin = nil\r\n        fp = nil\r\n      end\r\n    end\r\n    if not fp then\r\n      I:Log(\"Aiming at AI aimpoint\")\r\n      fp = target.AimPointPosition - target.Position\r\n      fp = fp + aimOffset(fp, target.Position, target.Velocity, eRot, false)\r\n    end\r\n\r\n    local ready = origin ~= nil\r\n    FireAtFirepoint(I, fp, target, ready)\r\n  end\r\n\r\n  function UpdateEnemyData(I)\r\n    for id, en in pairs(enemies) do\r\n      en.valid = false\r\n    end\r\n    for tarIdx = 0, I:GetNumberOfTargets(mainframeIdx) - 1 do\r\n      local target = I:GetTargetInfo(mainframeIdx, tarIdx)\r\n      if target.Valid then\r\n        if not enemies[target.Id] then\r\n          local rbsize = targetTrackTime * TICKS_PER_S\r\n          local newEnemy = {\r\n                              pos = RingBuffer.RingBuffer(rbsize),\r\n                              vel = RingBuffer.RingBuffer(rbsize),\r\n                              rotation = RingBuffer.RingBuffer(rbsize),\r\n                              origins = RingBuffer.RingBuffer(numOrigins),\r\n                              density = Stats.Distribution({\"x\", \"y\", \"z\"}),\r\n                              valid = true,\r\n                              oldAimpoints = {},\r\n                              aimpoints = {},\r\n                            }\r\n          newEnemy.density.n = 15\r\n          -- todo: set initial size estimate based on block count\r\n          newEnemy.density.cov = Matrix3.scalarmul(Matrix3.Identity(), 2500)\r\n          enemies[target.Id] = newEnemy\r\n        end\r\n        local e = enemies[target.Id]\r\n        e.valid = true\r\n        RingBuffer.push(e.pos, target.Position)\r\n        RingBuffer.push(e.vel, target.Velocity)\r\n      end\r\n    end\r\n\r\n    -- have to do this because there is no get target by id function\r\n    for id, en in pairs(enemies) do\r\n      if not en.valid then\r\n        enemies[id] = nil\r\n        if id == currentTargetId then\r\n          lastOrigin = nil\r\n          lastOriginSwitchTime = -originSwitchTime - 1\r\n          currentTargetId = nil\r\n        end\r\n      end\r\n    end\r\n\r\n    for idx, tracker in ipairs(aimPointTrackers) do\r\n      for tarIdx = 0, I:GetNumberOfTargets(tracker.idx) - 1 do\r\n        local target = I:GetTargetInfo(tracker.idx, tarIdx)\r\n        if target.Valid then\r\n          local e = enemies[target.Id]\r\n          e.oldAimpoints[idx] = e.aimpoints[idx] or target.AimPointPosition\r\n          e.aimpoints[idx] = target.AimPointPosition\r\n        end\r\n      end\r\n    end\r\n\r\n    for id, en in pairs(enemies) do\r\n      local dRot, consensusPoints = GetRotation(en.oldAimpoints, en.aimpoints)\r\n      if dRot then\r\n        RingBuffer.push(en.rotation, dRot * (en.rotation[en.rotation.size] or Quaternion.identity))\r\n        local changedAimpoints = {}\r\n        local nTrack = #en.aimpoints\r\n        local refIdx = consensusPoints[1]\r\n        local invRot = Quaternion.Inverse(en.rotation[en.rotation.size])\r\n        for i=1, nTrack do\r\n          local predicted = dRot * (en.oldAimpoints[i] - en.oldAimpoints[refIdx]) + en.aimpoints[refIdx]\r\n          if (predicted - en.aimpoints[i]).sqrMagnitude > 3 * 3 then\r\n            table.insert(changedAimpoints, invRot * (en.aimpoints[i] - en.pos[en.pos.size]))\r\n          end\r\n        end\r\n        -- Only update distribution if aimpoint has changed\r\n        Stats.updateDistributionBatched(en.density, changedAimpoints)\r\n        -- reduce n so distribution is allowed to change faster\r\n        en.density.n = math.min(en.density.n, 50)\r\n      else\r\n        RingBuffer.push(en.rotation, en.rotation[en.rotation.size] or Quaternion.identity)\r\n        trackLossTime = trackLossTime + 1 / TICKS_PER_S\r\n      end\r\n    end\r\n  end\r\n\r\n  function CheckStability(stability)\r\n    if stabilityAvgTime > 0 then\r\n      stabilityAvg = (1 - 1 / (TICKS_PER_S * stabilityAvgTime)) * stabilityAvg + stability / (TICKS_PER_S * stabilityAvgTime)\r\n    end\r\n    if stabilityMaxTime > 0 then\r\n      while LinkedList.peekBack(stabilityWindow) and LinkedList.peekBack(stabilityWindow).s <= stability do\r\n        LinkedList.popBack(stabilityWindow)\r\n      end\r\n      while LinkedList.peekFront(stabilityWindow) and LinkedList.peekFront(stabilityWindow).t < t - stabilityMaxTime do\r\n        LinkedList.popFront(stabilityWindow)\r\n      end\r\n      LinkedList.pushBack(stabilityWindow, { s=stability, t=t } )\r\n    end\r\n  end\r\n\r\n  function GetProjectile(I, alt, relBear, dist)\r\n    if dist == 0 then\r\n      return nil\r\n    end\r\n    local com = I:GetConstructCenterOfMass()\r\n    local relAlt = alt - com.y\r\n    dist = math.sqrt(dist * dist - relAlt * relAlt)\r\n    local projectile = Vector3(0, alt, dist)\r\n    projectile = Quaternion.AngleAxis(I:GetConstructYaw() + relBear, Vector3.up) * projectile\r\n    projectile = projectile + com\r\n    projectile.y = alt\r\n\r\n    return projectile\r\n  end\r\n\r\n  function GetOrigin(I, line, enemy)\r\n    if prevTime and RingBuffer.isFull(enemy.pos) then\r\n      prevTime = prevTime - 1\r\n    end\r\n    local relVel = line.ds / line.dt - Vector3(0, line.dv, 0) - enemy.vel[enemy.vel.size]\r\n    local relPos = line.ed - enemy.pos[enemy.pos.size]\r\n    local time2d = math.sqrt((relPos.x ^ 2 + relPos.z ^ 2) / (relVel.x ^ 2 + relVel.z ^2))\r\n    local tIdx2d = enemy.pos.size - math.floor(time2d * TICKS_PER_S + 0.5)\r\n    local g = I:GetGravityForAltitude(currentLine.start.y)\r\n    local estimate2d = relPos - (relVel * time2d) + 0.5 * g * time2d * time2d\r\n    if tIdx2d > 0 then\r\n      estimate2d = Quaternion.Inverse(enemy.rotation[tIdx2d]) * estimate2d\r\n    end\r\n    local covInv = Matrix3.inverse(enemy.density.cov)\r\n    if Matrix3.quadform(estimate2d, covInv, estimate2d) < 5 * 5 then\r\n      local closest, closestTimeIdx = RunTrace(I, line, enemy, prevTime)\r\n      if not closest then\r\n        prevTime = nil\r\n        return\r\n      end\r\n      prevTime = closestTimeIdx\r\n      local launchPos, launchTime\r\n      if cramCounter then\r\n        launchPos, launchTime = CheckIfCram(I, line, enemy, closestTimeIdx)\r\n      end\r\n      if launchPos then\r\n        I:Log(string.format(\"Projectile determined to be CRAM shell, fired %f seconds ago\", launchTime))\r\n        local pIdx = enemy.pos.size + math.floor(launchTime * TICKS_PER_S)\r\n        if pIdx < 1 or pIdx > enemy.pos.size then\r\n          I:Log(\"CRAM guess has no target data\")\r\n          return\r\n        end\r\n        local enemyPosAtTime = enemy.pos[pIdx]\r\n        local enemyRotAtTime = enemy.rotation[pIdx]\r\n        local launchAlt = (enemyPosAtTime + launchPos).y\r\n        if launchAlt > minAlt and launchAlt < maxAlt then\r\n          local origin = {\r\n            position = Quaternion.Inverse(enemyRotAtTime) * launchPos,\r\n            time = t + launchTime,\r\n            relVel = line.ev * TICKS_PER_S + g * launchTime - enemy.vel[pIdx],\r\n            rot = enemyRotAtTime,\r\n            detectTime = t,\r\n            detectPos = line.ed,\r\n            type = 1,\r\n          }\r\n          return origin\r\n        end\r\n      end\r\n      local eRot = enemy.rotation[closestTimeIdx]\r\n      local closestRotated = Quaternion.Inverse(eRot) * closest\r\n      if Matrix3.quadform(closestRotated, covInv, closestRotated) < 4 * 4 then\r\n        local closestAlt = closest.y + enemy.pos[closestTimeIdx].y\r\n        if closestAlt > minAlt and closestAlt < maxAlt then\r\n          local origin = {\r\n            position = closestRotated,\r\n            time = t + (closestTimeIdx - enemy.pos.size) / TICKS_PER_S,\r\n            relVel = line.ev / frameTime + g * t - enemy.vel[closestTimeIdx],\r\n            rot = eRot,\r\n            detectTime = t,\r\n            detectPos = line.ed,\r\n            type = 0,\r\n          }\r\n          return origin\r\n        end\r\n      end\r\n    end\r\n  end\r\n\r\n  function GetMissileOrigin(I, enemy)\r\n    local origins = {}\r\n    for widx = 0, I:GetNumberOfWarnings(mainframeIdx) - 1 do\r\n      local warn = I:GetMissileWarning(mainframeIdx, widx)\r\n      if warn.Valid and not foundMissiles[warn.Id] and warn.TimeSinceLaunch < 0.1 then\r\n        foundMissiles[warn.Id] = 1\r\n        local launcherPos = warn.Position - warn.TimeSinceLaunch * warn.Velocity\r\n        local tIdx = enemy.pos.size - warn.TimeSinceLaunch * TICKS_PER_S\r\n        local targetPosAtLaunch = enemy.pos[tIdx]\r\n        -- todo: set threshold by target size\r\n        local diff = Quaternion.Inverse(enemy.rotation[tIdx]) * (launcherPos - targetPosAtLaunch)\r\n        if Matrix3.quadform(diff, Matrix3.inverse(enemy.density.cov), diff) < 4 * 4 then\r\n          local closestAlt = launcherPos.y\r\n          if closestAlt > minAlt and closestAlt < maxAlt then\r\n            local lPos = launcherPos - targetPosAtLaunch\r\n            local origin = {\r\n              position = lPos,\r\n              time = t - warn.TimeSinceLaunch,\r\n              relVel = warn.Velocity - enemy.vel[enemy.vel.size],\r\n              rot = eRot,\r\n              detectTime = t,\r\n              detectPos = warn.Position,\r\n              type = 2,\r\n            }\r\n            table.insert(origins, origin)\r\n          end\r\n        end\r\n      end\r\n    end\r\n    return origins\r\n  end\r\n\r\n  function GetRotation(oldPts, newPts, iterLim)\r\n    local nTrack = #newPts\r\n    iterLim = iterLim or 25\r\n\r\n    local indices = {}\r\n    for i=1, nTrack do\r\n      indices[i] = i\r\n    end\r\n    local consensusPoints = {}\r\n    -- iterate through triples of aimpoints, check if the legs are the same length\r\n    for trip=1, iterLim do\r\n      -- not the most efficient as we shuffle the entire list even though we only need the first 3. Implement range shuffle later\r\n      MathUtil.shuffle(indices, true)\r\n      local oldAimpoints = {}\r\n      local aimpoints = {}\r\n      for i=1, 3 do\r\n        oldAimpoints[i] = oldPts[indices[i]]\r\n        aimpoints[i] = newPts[indices[i]]\r\n      end\r\n\r\n      local legs, oldLegs = {}, {}\r\n      local valid = true\r\n      for i=1, 3 do\r\n        legs[i] = aimpoints[i % 3 + 1] - aimpoints[(i - 1) % 3 + 1]\r\n        oldLegs[i] = oldAimpoints[i % 3 + 1] - oldAimpoints[(i - 1) % 3 + 1]\r\n        -- check if aimpoints have changed\r\n        if math.abs(legs[i].sqrMagnitude - oldLegs[i].sqrMagnitude) > 0.1 then\r\n          valid = false\r\n          break\r\n        end\r\n      end\r\n      if valid then\r\n        local oldRot = Quaternion.LookRotation(oldLegs[1], oldLegs[2])\r\n        local rot = Quaternion.LookRotation(legs[1], legs[2])\r\n        local deltaRot = rot * Quaternion.Inverse(oldRot)\r\n        if math.acos(math.max(math.min(deltaRot.w, 1), -1)) * 360 / math.pi * TICKS_PER_S < maxTurnRateTracking then\r\n          -- check for consensus\r\n          local votes = 0\r\n          for idx, ap in ipairs(newPts) do\r\n            local diff = ap - newPts[indices[1]]\r\n            local oldDiff = oldPts[idx] - oldPts[indices[1]]\r\n            if (diff - deltaRot * oldDiff).sqrMagnitude < 0.1 then\r\n              votes = votes + 1\r\n              table.insert(consensusPoints, idx)\r\n            end\r\n            if 2 * votes - 3 >= nTrack then\r\n              return deltaRot, consensusPoints\r\n            end\r\n            consensusPoints = {}\r\n          end\r\n        end\r\n      end\r\n    end\r\n    return nil\r\n  end\r\n\r\n  function CheckIfCram(I, line, enemy, closestTimeIdx)\r\n    local projPos = line.ed\r\n    local projVel = line.ev * TICKS_PER_S\r\n    local bestD, bestS, bestR\r\n    local bestScoreD = -math.huge\r\n    local bestScoreS = -math.huge\r\n    local bestScoreR = -math.huge\r\n    local t1, t2 = MathUtil.solveQuadratic(-9.81, projVel.y, projPos.y)\r\n    if not t1 then return end\r\n    for i = math.max(closestTimeIdx - 10, math.floor(t2 * TICKS_PER_S) + enemy.vel.size, 1), math.min(closestTimeIdx + 10, math.floor(t1 * TICKS_PER_S) + enemy.vel.size, enemy.vel.size) do\r\n      if enemy.vel[i] then\r\n        local iTime = (i - enemy.vel.size) / TICKS_PER_S\r\n        local projPosAtTime = projPos + projVel * iTime - Vector3(0, 0.5 * 9.81 * iTime * iTime, 0)\r\n        local relVelAtClosest = projVel\r\n        relVelAtClosest = relVelAtClosest - enemy.vel[i]\r\n        -- this line goes after because we don't want to modify the original projVel\r\n        relVelAtClosest.y = relVelAtClosest.y - 9.81 * iTime\r\n        local dScore = -1000 * math.abs(relVelAtClosest.magnitude - 300) - 0.01 * (projPosAtTime - enemy.pos[i]).magnitude\r\n        local sScore = -1000 * math.abs(relVelAtClosest.magnitude - 240) - 0.01 * (projPosAtTime - enemy.pos[i]).magnitude\r\n        local rScore = -1000 * math.abs(relVelAtClosest.magnitude - 285) - 0.01 * (projPosAtTime - enemy.pos[i]).magnitude\r\n        if dScore > bestScoreD then\r\n          bestD = i\r\n          bestScoreD = dScore\r\n        end\r\n        if sScore > bestScoreS then\r\n          bestS = i\r\n          bestScoreS = sScore\r\n        end\r\n        if rScore > bestScoreR then\r\n          bestR = i\r\n          bestScoreR = rScore\r\n        end\r\n      end\r\n    end\r\n    local idx\r\n    if bestScoreD > -3000 and bestScoreD > bestScoreS and bestScoreD > bestScoreR then\r\n      idx = bestD\r\n    elseif bestScoreS > -3000 and bestScoreS > bestScoreR then\r\n      idx = bestS\r\n    elseif bestScoreR > -3000 then\r\n      idx = bestR\r\n    else\r\n      return\r\n    end\r\n    idx = math.max(idx - 1, 1)\r\n    local launchTime = (idx - enemy.vel.size) / TICKS_PER_S\r\n    local projPosAtTime = projPos + projVel * launchTime - Vector3(0, 0.5 * 9.81 * launchTime * launchTime, 0)\r\n    local p = projPosAtTime - enemy.pos[idx]\r\n    return p, launchTime\r\n  end\r\n\r\n  function PickTargetOrigin(I, enemy)\r\n    local origin\r\n    local eRot = enemy.rotation[enemy.rotation.size] or Quaternion.identity\r\n    while enemy.origins.size > 0 and t - enemy.origins[1].detectTime > maxStaleness do\r\n      RingBuffer.pop(enemy.origins)\r\n      originPopTime = t\r\n    end\r\n    if enemy.origins.size == 0 then\r\n      I:Log(\"No origins found.\")\r\n    else\r\n      local candidate = enemy.origins[math.random(1, enemy.origins.size)]\r\n      local originAlt = (eRot * candidate.position).y + enemy.pos[enemy.pos.size].y\r\n      if originAlt < minAlt or originAlt > maxAlt then\r\n        -- do a linear search to find valid origin\r\n        for i = 1, enemy.origins.size do\r\n          candidate = enemy.origins[i]\r\n          originAlt = (eRot * candidate.position).y + enemy.pos[enemy.pos.size].y\r\n          if originAlt > minAlt and originAlt < maxAlt then\r\n            origin = candidate\r\n            break\r\n          end\r\n        end\r\n        if not origin then\r\n          I:Log(\"No origin in bounds.\")\r\n        end\r\n      else\r\n        origin = candidate\r\n      end\r\n    end\r\n    return origin\r\n  end\r\n\r\n  function PerformACBCheck(I, fp, target)\r\n    -- check ACBs for object presence\r\n    local valid = 0\r\n    local score = 0\r\n    for acbIdx, acb in ipairs(checkACBs) do\r\n      local bInfo = I:GetSubConstructInfo(acb.turretSub)\r\n      local r = fp + target.Position - (bInfo.Position + bInfo.Rotation * acb.offset)\r\n      BlockUtil.aimWeapon(I, acb.turret, r, 0)\r\n      if r.magnitude > acb.minRange and r.magnitude < acb.maxRange\r\n          and I:IsAlive(acb.turretSub)\r\n          and Vector3.Angle(r, bInfo.Forwards) < AIM_TOL then\r\n        local val = I:GetCustomAxis(acb.axis)\r\n        if val ~= 0 or not acb.inverted then\r\n          score = score + I:GetCustomAxis(acb.axis)\r\n          valid = valid + 1\r\n        end\r\n      end\r\n    end\r\n    if valid < validACBRequire or score < checkACBRequire * valid then\r\n      I:Log(string.format(\"Origin ACB check failed: score %.2f of %.2f required with %d valid ACBs of %d required\", score, checkACBRequire * valid, valid, validACBRequire))\r\n      return false\r\n    else\r\n      I:Log(\"Origin ACB check passed\")\r\n      return true\r\n    end\r\n  end\r\n\r\n  function FireAtFirepoint(I, fp, target, ready)\r\n    if not ready and idleAim == \"none\" then return end\r\n    local fpAlt = fp.y + target.Position.y\r\n    for i, turret in ipairs(turrets) do\r\n      if fpAlt >= weaponDef[i].minAlt and fpAlt <= weaponDef[i].maxAlt then\r\n        for j, weapon in ipairs(turret) do\r\n          local aim\r\n          local fire = false\r\n          local wInfo = BlockUtil.getWeaponInfo(I, weapon)\r\n          local mv = weaponDef[i].velocity or (wInfo.Speed > 1e5 and math.huge or wInfo.Speed)\r\n          if not ready and idleAim == \"last\" then\r\n            aim = lastAim\r\n          elseif not wInfo.PlayerCurrentlyControllingIt then\r\n            if mv == math.huge then\r\n              local range = (fp + target.Position - I:GetConstructPosition()).magnitude\r\n              if range > (weaponDef[i].minRange or 0) and range < (weaponDef[i].maxRange or math.huge) then\r\n                aim = fp + target.Position - wInfo.GlobalFirePoint\r\n                fire = ready\r\n              end\r\n            else\r\n              local g = 0.5 * (I:GetGravityForAltitude(I:GetConstructPosition().y) + I:GetGravityForAltitude(target.Position.y))\r\n              aim, interceptTime = Targeting.secondOrderTargeting(fp + target.Position - wInfo.GlobalFirePoint,\r\n                          target.Velocity - I:GetVelocityVector(),\r\n                          -g,\r\n                          mv, weaponDef[i].minRange, weaponDef[i].maxRange, weapon.lastT or nil)\r\n              if aim then fire = ready end\r\n              weapon.lastT = interceptTime\r\n            end\r\n          else\r\n            I:Log(\"Holding fire for player.\")\r\n          end\r\n          if aim then \r\n            ready = ready or (idleAim == \"fire\" or (idleAim == \"timer\" and t - originPopTime > waitTime))\r\n          end\r\n          if not aim then\r\n            if idleAim == \"enemy\" or idleAim == \"fire\" or idleAim == \"timer\" then\r\n              aim = target.AimPointPosition - wInfo.GlobalFirePoint\r\n            end\r\n          end\r\n          if aim then\r\n            lastAim = aim\r\n            if Combat.CheckConstraints(I, aim, weapon.wpnIdx, weapon.subIdx) then\r\n              BlockUtil.aimWeapon(I, weapon, aim, 0)\r\n              if fire then\r\n                local stability = I:GetCustomAxis(stabilityAxisName)\r\n                if stability and ((minStabilityToFire >= 0 and stability >= minStabilityToFire) or stability >= stabilityAvg or stabilityWindow.next.next == stabilityWindow) then\r\n                  -- angle tolerance needs to be pretty big because wInfo.CurrentDirection is unreliable for projectile weapons\r\n                  -- hitscan weapons will not fire if they can't aim in the desired direction anyways\r\n                  if Vector3.Angle(aim, wInfo.CurrentDirection) > 5 or not BlockUtil.fireWeapon(I, weapon, 0) then\r\n                    I:Log(\"Holding fire for aim or reloading.\")\r\n                  else\r\n                    I:Log(\"Fire!\")\r\n                  end\r\n                else\r\n                  I:Log(\"Holding fire for stability.\")\r\n                end\r\n              end\r\n            else\r\n              I:Log(\"Holding fire for constraints.\")\r\n            end\r\n          end\r\n        end\r\n      else\r\n        I:Log(\"Holding fire for altitude.\")\r\n      end\r\n    end\r\n  end\r\n\r\n  function CheckAndUpdateLine(I, line, projectile, tolerance)\r\n    if line.start then\r\n      -- the theoretical equation has a 0.5 before the quadratic term, but discrete integration results in no 0.5\r\n      local expected = line.ed + line.ev + frameTime * frameTime * I:GetGravityForAltitude(line.ed.y)\r\n      local dv = line.dv - frameTime * I:GetGravityForAltitude(line.ed.y).y\r\n      local dy = line.dy + frameTime * line.dv\r\n      if (expected - projectile).sqrMagnitude <= tolerance * tolerance then\r\n        line.ds = projectile + line.dy * Vector3.up - line.start\r\n        line.dv = dv\r\n        line.dy = dy\r\n        line.dt = I:GetTimeSinceSpawn() - line.tStart\r\n        line.ev = projectile - line.ed\r\n        line.ed = projectile\r\n        return true\r\n      end\r\n    end\r\n    line.start = lastProjectilePos\r\n    line.tStart = t - frameTime\r\n    line.ed = projectile\r\n    line.dv = -frameTime * I:GetGravityForAltitude(line.start.y).y\r\n    line.dy = frameTime * line.dv\r\n    line.ds = projectile + line.dy * Vector3.up - lastProjectilePos\r\n    line.dt = frameTime\r\n    line.ev = projectile - lastProjectilePos\r\n    prevTime = nil\r\n    return false\r\n  end\r\n\r\n  function RunTrace(I, line, enemy, timeGuess)\r\n    local totalIter = 0\r\n    local targetPos = enemy.pos[enemy.pos.size]\r\n    local targetVel = enemy.vel[enemy.vel.size]\r\n    if timeGuess then\r\n      if enemy.pos[timeGuess] then\r\n        targetPos = enemy.pos[timeGuess]\r\n        targetVel = enemy.vel[timeGuess]\r\n      else\r\n        I:Log(\"Initial guess has no target data\")\r\n      end\r\n    end\r\n    local tIdxClosest = timeGuess or enemy.pos.size\r\n    local cov = enemy.density.cov\r\n    local covInv = Matrix3.inverse(cov)\r\n    -- due to bug in FtD's Lua interpreter, inverse is sometimes negated or has columns that are circularly shifted one to the right\r\n    if Matrix3.determinant(covInv) < 0 then\r\n      covInv = -covInv\r\n    end\r\n    if Matrix3.get(covInv, 1, 2) ~= Matrix3.get(covInv, 2, 1) then\r\n      for row=1,3 do\r\n        local temp = covInv[(row - 1) * 3 + 1]\r\n        for col=1,2 do\r\n          covInv[(row - 1) * 3 + col] = covInv[(row - 1) * 3 + col + 1]\r\n        end\r\n        covInv[(row - 1) * 3 + 3] = temp\r\n      end\r\n    end\r\n    local iters = tIdxClosest and 2 or 3\r\n    for i = 1, iters do\r\n      -- find the point of closest approach based on current target position and velocity\r\n      -- x(t) = x_i + v_x t\r\n      -- z(t) = z_i + v_z t\r\n      -- y(t) = y_i + v_y t + 0.5gt^2\r\n      -- squared distance = x^2 + y^2 + z^2\r\n\r\n      -- sqr Mahalanobis distance = x^T S^-1 x = (x_0 + x'_0 t + 0.5 g t^2)^T S^-1 x\r\n      -- x'(t) = v_i + g t\r\n\r\n      -- d/dt sqrDistance = \r\n      -- 2 x_i v_x + 2 v_x^2 t +\r\n      -- 2 z_i v_z + 2 v_z^2 t +\r\n      -- 2 y_i v_y + 2 v_y^2 t + 2 y_i g t + 3 v_y g t^2 + g^2 t^3\r\n      -- this is a cubic polynomial in terms of t which we can find the roots of\r\n\r\n      -- d/dt sqrMaha = 2 x(t)^T S^-1 x'(t) = 2 (x_i + v_i t + 0.5g t^2) S^-1 (v_i + g t)\r\n      -- = 2 (x_i S^-1 v_i + x_i S^-1 g t + v_i t S^-1 v_i + v_i t S^-1 g t + 0.5g t^2 S^-1 v_i + 0.5 g t^2 S^-1 g t)\r\n      -- = 2 (x_i S^-1 v_1 + (x_i S^-1 g + v_i S^-1 v_i) t + (v_i S^-1 g + 0.5 g S^-1 v_i) t^2 + 0.5 g S^-1 g t^3)\r\n\r\n      local ti = line.tStart - (t - (enemy.pos.size - tIdxClosest) / TICKS_PER_S) -- time from guess to line start\r\n      local di = line.start - (targetPos + ti * targetVel)\r\n      local projRelVel = line.ds / line.dt - targetVel\r\n      -- accounting exactly for gravity changes over altitude is difficult, just approximate and hope the enemy isn't using mortars\r\n      local g = I:GetGravityForAltitude(line.start.y)\r\n      -- local a, b, c = MathUtil.solveCubic(0.5 * g * g, 1.5 * projRelVel.y * g, projRelVel.sqrMagnitude + di.y * g, Vector3.Dot(di, projRelVel))\r\n      -- when covariance matrix is the identity, this matches the case without using the covariance matrix\r\n      local q3 = 0.5 * Matrix3.quadform(g, covInv, g)\r\n      local q2 = Matrix3.quadform(projRelVel, covInv, g) + 0.5 * Matrix3.quadform(g, covInv, projRelVel)\r\n      local q1 = Matrix3.quadform(di, covInv, g) + Matrix3.quadform(projRelVel, covInv, projRelVel)\r\n      local q0 = Matrix3.quadform(di, covInv, projRelVel)\r\n      local a, b, c = MathUtil.solveCubic(q3, q2, q1, q0)\r\n      -- critical point is a minimum when derivative changes from negative to positive\r\n      -- since leading term is always nonnegative (covariance is always positive semidefinite), if there are three roots, the first and third are minima\r\n      -- if there is one root, it is a minimum\r\n      -- minRoot is in seconds relative to line.tStart + line.dt\r\n      local minRoot\r\n      if a and b and c then\r\n        local firstRoot = math.min(a, b, c)\r\n        local lastRoot = math.max(a, b, c)\r\n        local firstSqrDist = SqrDistance(I, line, targetPos, targetVel, firstRoot)\r\n        local lastSqrDist = SqrDistance(I, line, targetPos, targetVel, lastRoot)\r\n        if firstSqrDist < lastSqrDist then\r\n          minRoot = firstRoot\r\n        else\r\n          minRoot = lastRoot\r\n        end\r\n      else\r\n        minRoot = a\r\n      end\r\n      -- get target position and velocity at estimated time of closest approach\r\n      local approachTime = minRoot + line.tStart - t\r\n      tIdxClosest = math.floor(approachTime * TICKS_PER_S + 0.5) + enemy.pos.size\r\n      if not tIdxClosest then return nil end\r\n      targetPos = enemy.pos[tIdxClosest]\r\n      targetVel = enemy.vel[tIdxClosest]\r\n      if not targetPos then\r\n        I:Log(string.format(\"Solved cubic %f x^3 + %f x^2 + %f x + %f\", q3, q2, q1, q0))\r\n        I:Log(string.format(\"Iterated guess has no target data. Shell estimated to have been fired %f seconds ago\", approachTime))\r\n        return nil\r\n      end\r\n    end\r\n\r\n    -- linear search to find best point\r\n    -- todo: account for target velocity\r\n    function CalcSqrMahaDist(tIdx)\r\n      local dt = t - (enemy.pos.size - tIdx) / TICKS_PER_S - line.tStart\r\n      local diff = line.start - enemy.pos[tIdx] + dt * line.ds / line.dt + 0.5 * I:GetGravityForAltitude(line.start.y) * dt * dt\r\n      diff = Quaternion.Inverse(enemy.rotation[tIdx]) * diff\r\n      return Matrix3.quadform(diff, covInv, diff)\r\n    end\r\n    local currentSqrDist = CalcSqrMahaDist(tIdxClosest)\r\n    if tIdxClosest < enemy.pos.size then\r\n      local aftSqrDist = CalcSqrMahaDist(tIdxClosest + 1)\r\n      while aftSqrDist < currentSqrDist and tIdxClosest < enemy.pos.size do\r\n        currentSqrDist = aftSqrDist\r\n        tIdxClosest = tIdxClosest + 1\r\n        if tIdxClosest < enemy.pos.size then\r\n          aftSqrDist = CalcSqrMahaDist(tIdxClosest + 1)\r\n        end\r\n        totalIter = totalIter + 1\r\n        if totalIter >= 100 then\r\n          I:Log(\"Max iterations exceeded on upwards search\")\r\n          break\r\n        end\r\n      end\r\n    end\r\n    --I:Log(totalIter..\" iterations after upwards search\")\r\n    if tIdxClosest > 1 then\r\n      local befSqrDist = CalcSqrMahaDist(tIdxClosest - 1)\r\n      while befSqrDist < currentSqrDist and tIdxClosest > 1 do\r\n        currentSqrDist = befSqrDist\r\n        tIdxClosest = tIdxClosest - 1\r\n        if tIdxClosest > 1 then\r\n          befSqrDist = CalcSqrMahaDist(tIdxClosest -1)\r\n        end\r\n        totalIter = totalIter + 1\r\n        if totalIter >= 100 then\r\n          I:Log(\"Max iterations exceeded on downwards search\")\r\n          break\r\n        end\r\n      end\r\n    end\r\n    --I:Log(totalIter..\" iterations after downwards search\")\r\n    -- time of closest approach relative to line.tStart\r\n    local dt = t - (enemy.pos.size - tIdxClosest) / TICKS_PER_S - line.tStart\r\n    return line.start - enemy.pos[tIdxClosest] + dt * (line.ds / line.dt) + 0.5 * I:GetGravityForAltitude(line.start.y) * dt * dt, tIdxClosest\r\n  end\r\n\r\n  function SqrDistance(I, line, targetAbsPos, targetAbsVel, dt)\r\n    local di = line.start - targetAbsPos\r\n    local viRel = line.ds / line.dt - targetAbsVel\r\n    local diff = di + dt * viRel + 0.5 * I:GetGravityForAltitude(line.start.y) * dt * dt\r\n    return diff.sqrMagnitude\r\n  end\r\n\r\n  -- minified version of Tides library (not meant to be human-readable, see Tides.lua or individual class files for human-readable source)\r\n  function Accumulator.Accumulator(a,b)local c={}c.decay=b;c.window=a;c.time=0;c.weight=0;if a>0 then c.vals=LinkedList.LinkedList()c.times=LinkedList.LinkedList()end;return c end;function Accumulator.update(c,d,e)local f=Mathf.Pow(c.decay,e)if not c.value then c.value=d*e else c.value=c.value*f;c.value=c.value+d*e end;c.time=c.time+e;c.weight=c.weight*f;c.weight=c.weight+e;if c.window>0 then LinkedList.pushFront(c.vals,d)LinkedList.pushFront(c.times,e)while c.time>c.window do local g=LinkedList.popBack(c.times)c.time=c.time-g;local h=Mathf.Pow(c.decay,c.time)c.weight=c.weight-g*h;c.value=c.value-LinkedList.popBack(c.vals)*g*h end end;return c.value,c.weight end;function Accumulator.get(c)return c.value,c.weight end;function Differ.Differ(i)local j={}j.lastVal=i;j.diff=nil;return j end;function Differ.update(j,d)if j.lastVal then j.diff=d-j.lastVal;j.lastVal=d end;j.lastVal=d;return j.diff end;function Differ.get(j)return j.diff end;function Heapq.Heapq(i,k)local l={}l.data=i;l.comp=k or function(m,n)return m<n end;local o=#l.data;l.size=o;for p=math.floor(o/2),1,-1 do Heapq.siftDown(l,p)end;return l end;function Heapq.siftDown(l,q)local r=false;local s=q;local o=#l.data;while not r do r=true;local t=2*s;local u=2*s+1;local v=s;if t<=o and l.comp(l.data[t],l.data[v])then v=t;r=false end;if u<=o and l.comp(l.data[u],l.data[v])then v=u;r=false end;if not r then local w=l.data[v]l.data[v]=l.data[s]l.data[s]=w;s=v end end end;function Heapq.siftUp(l,q)local r=false;local s=q;while not r do r=true;local x=math.floor(s/2)if l.comp(l.data[s],l.data[x])then local w=l.data[x]l.data[x]=l.data[s]l.data[s]=w;s=x;r=false end end end;function Heapq.insert(l,y)l.data[l.size+1]=y;l.size=l.size+1;Heapq.siftUp(l,l.size)end;function Heapq.pop(l)local z=l.data[1]l.data[1]=l.data[l.size]l.data[l.size]=nil;l.size=l.size-1;Heapq.siftDown(l,1)return z end;function Heapq.peek(l)return l.data[1]end;function Heapq.size(l)return l.size end;function LinkedList.LinkedList()local A={}A.value=nil;A.next=A;A.prev=A;return A end;function LinkedList.pushFront(B,d)local A={}A.value=d;LinkedList.connect(A,B.next)LinkedList.connect(B,A)end;function LinkedList.pushBack(B,d)local A={}A.value=d;LinkedList.connect(B.prev,A)LinkedList.connect(A,B)end;function LinkedList.popFront(B)local C=B.next.value;LinkedList.connect(B,B.next.next)return C end;function LinkedList.popBack(B)local C=B.prev.value;LinkedList.connect(B.prev.prev,B)return C end;function LinkedList.peekFront(B)return B.next.val end;function LinkedList.peekBack(B)return B.prev.val end;function LinkedList.connect(D,E)D.next=E;E.prev=D end;function LinkedList.toArray(B)local F=1;local G={}local A=B.next;while A~=B do G[F]=A.value;A=A.next end;return G end;function MathUtil.angleOnPlane(H,I,J)local K=Vector3.ProjectOnPlane(H,J)local g=Vector3.ProjectOnPlane(I,J)return Vector3.SignedAngle(K,g,J)end;function MathUtil.min(L,M)local N=nil;M=M or function(m,n)return m<n end;for O in L do if not N or M(O,N)then N=O end end;return N end;function MathUtil.max(L,M)local P=nil;M=M or function(m,n)return m<n end;for O in L do if not P or M(P,O)then P=O end end;return P end;function MathUtil.range(m,n,Q)local R,S=m,n;local T;if not m then return end;if not n then R=0;S=m;T=R<S and 1 or-1 elseif Q then T=Q end;return function(U,V)local W=V+T;if W==S then return nil end;return W end,nil,R-T end;function MathUtil.shuffle(B,X)local s=X and B or{}if not X then for F=1,#B do s[F]=B[F]end end;for F=#B,2,-1 do local Y=math.random(F)s[F],s[Y]=s[Y],s[F]end;return s end;function MathUtil.combine(m,n,Z)if#m==#n then local z={}for _,a0 in pairs(m)do z[_]=Z(_,a0,n[_])end;return z end end;function MathUtil.angleSSS(m,n,Q)if m+n<Q or m+Q<n or n+Q<m then return nil end;local a1=math.deg(math.acos((n*n+Q*Q-m*m)/(2*n*Q)))local a2,a3=MathUtil.angleSAS(n,a1,Q)return a1,a2,a3 end;function MathUtil.sideSAS(m,a3,n)local a4=m*m+n*n-2*m*n*math.cos(math.rad(a3))return math.sqrt(a4)end;function MathUtil.angleSAS(m,a3,n)local Q=MathUtil.sideSAS(m,a3,n)if MathUtil.isZero(Q)then return nil end;local a1,a2;if m<n then a1=MathUtil.angleLoSin(Q,m,a3)a2=180-a1-a3 else a2=MathUtil.angleLoSin(Q,n,a3)a1=180-a2-a3 end;return a1,a2 end;function MathUtil.sideSSA(m,n,a1)local a5=n*n-m*m;local a6=-2*n*math.cos(math.rad(a1))local a7,a8=MathUtil.solveQuadratic(1,a6,a5)if not a8 then return a7,a8 end;if a7<a8 then return a7,a8 end;return a8,a7 end;function MathUtil.angleSSA(m,n,a1)local a7,a8=MathUtil.sideSSA(m,n,a1)if not a7 then return nil end;local a9,aa=MathUtil.angleSAS(n,a1,a7)if not a8 then return a9,aa end;local ab,ac=MathUtil.angleSAS(n,a1,a8)return a9,aa,ab,ac end;function MathUtil.sideAAS(a1,a2,m)local a3=180-a1-a2;local n=MathUtil.sideLoSin(a1,a2,m)local Q=MathUtil.sideLoSin(a1,a3,m)return n,Q end;function MathUtil.sideLoSin(m,a1,a2)return m*math.sin(math.rad(a2))/math.sin(math.rad(a1))end;function MathUtil.angleLoSin(m,n,a1)return math.deg(math.asin(n*math.sin(math.rad(a1))/m))end;function MathUtil.clampCone(ad,ae,af)local ag=math.min(af,Vector3.Angle(ad,ae))local ah=Vector3.Cross(ad,ae)return Quaternion.AngleAxis(ag,ah)*ad end;function MathUtil.newton(ai,aj,ak,al,am,an)al=al or 1e-5;an=an or 10*al;am=am or 25;aj=aj or function(ao)return(ai(ao+an)-ai(ao))/an end;ak=ak or 0;local ap=al+1;local aq=0;while ap>al and aq<am do local ar=ai(ak)local as=aj(ak)if not ar or not as then return nil end;ap=-ar/as;ak=ak+ap;aq=aq+1 end;if aq<am then return ak,false end;return ak,true end;function MathUtil.ITP(ai,m,n,al,am)if ai(m)*ai(n)>0 then return nil end;if ai(m)>ai(n)then ai=function(ao)return-ai(ao)end end;al=al or 1e-5;am=am or 25;local at=0.2/(n-m)local au=2;local av=1;local aw=math.ceil(math.log((n-m)/(2*al),2))local ax=aw+av;local aq=am;for Y=1,am do local ay=ai(m)local az=ai(n)local aA=ay-az;if aA==0 then return m end;local aB=0.5*(m+n)local aC=(n*ay+m*az)/aA;if aB<m or aB>n then aB=0.5*(m+n)end;local aD=aB-aC;local aE=at*math.abs(n-m)^au;local aF=aD>0 and 1 or(aD==0 and 0 or-1)local aG=aE<=math.abs(aD)and aC+aF*aE or aB;local aH=al*2^(ax-Y)-0.5*(n-m)local aI=math.abs(aG-aB)<=aH and aG or aB-aF*aH;local aJ=ai(aI)if aJ>0 then n=aI elseif aJ<0 then m=aI else return aI,Y==am end;if n-m<2*al then aq=Y;break end end;local ay=ai(m)local az=ai(n)local aA=az-ay;if aA~=0 then return(m*az-n*ay)/aA,aq==am end;return m,aq==am end;function MathUtil.binomCoeffs(aK,aL)if aL then local aM={}else local aM={}aM[1]=1;for _=1,aK do aM[_+1]=aM[_]*(aK-_)/(_+1)end;return aM end end;function MathUtil.ruleOfSigns(aM,aN)local aO={}local aP=#aM;for F=1,aP do aO[F]=aM[aP-F+1]end;if aN~=0 then local aQ={}for F=1,aP do aQ[F]=(F-1)*aM[aP-F+1]end;local aR=1;for F=2,aP do local aS=aN^(F-1)for Y=1,aP-F+1 do local aT=F+Y-1;aO[Y]=aO[Y]+aR*aQ[aT]*aS;aQ[aT]=aQ[aT]*(Y-1)end;aR=aR/F end end;local aU={}local o=1;for F,aV in ipairs(aO)do if aV~=0 then aU[o]=aV;o=o+1 end end;local aW=0;for F=1,#aU-1 do if aU[F]*aU[F+1]<0 then aW=aW+1 end end;return aW end;function MathUtil.cache(ai)local Q={}local aX=getmetatable(Q)or{}function aX.__index(aY,ao)local C=ai(ao)aY[ao]=C;return C end;setmetatable(Q,aX)return function(m)return Q[m]end end;function MathUtil.lerp(ai,R,S,T,aZ)local a_={}for F=1,math.floor((S-R)/T)+1 do a_[F]=ai(R+F*T)end;a_.start=R;a_.stop=S;a_.step=T;a_.lval=aZ and a_[1]or nil;a_.rval=aZ and a_[#a_]or nil;return function(ao)if ao>=a_.stop then return a_.rval end;if ao<=a_.start then return a_.lval end;local F=(ao-a_.start)/a_.step;local b0=F%1;F=math.floor(F)return(1-b0)*a_[F]+b0*a_[F+1]end end;function MathUtil._factorial(o)if o<2 then return 1 end;return MathUtil._factorial(o-1)end;MathUtil.factorial=MathUtil.cache(MathUtil._factorial)MathUtil.eps=1e-9;function MathUtil.isZero(h)return h>-MathUtil.eps and h<MathUtil.eps end;function MathUtil.setTolerance(al)MathUtil.eps=al end;function MathUtil.cuberoot(ao)return ao>0 and ao^(1/3)or-math.abs(ao)^(1/3)end;function MathUtil.solveQuadratic(b1,a7,a8)local b2,b3;local b4,b5,b6;b4=a7/(2*b1)b5=a8/b1;b6=b4*b4-b5;if MathUtil.isZero(b6)then b2=-b4;return b2 elseif b6<0 then return else local b7=math.sqrt(b6)b2=b7-b4;b3=-b7-b4;return b2,b3 end end;function MathUtil.solveCubic(b1,a7,a8,b8)local b2,b3,b9;local ba,bb;local a1,a2,a3;local bc,b4,b5;local bd,b6;a1=a7/b1;a2=a8/b1;a3=b8/b1;bc=a1*a1;b4=1/3*(-(1/3)*bc+a2)b5=0.5*(2/27*a1*bc-1/3*a1*a2+a3)bd=b4*b4*b4;b6=b5*b5+bd;if MathUtil.isZero(b6)then if MathUtil.isZero(b5)then b2=0;ba=1 else local be=MathUtil.cuberoot(-b5)b2=2*be;b3=-be;ba=2 end elseif b6<0 then local bf=1/3*math.acos(-b5/math.sqrt(-bd))local g=2*math.sqrt(-b4)b2=g*math.cos(bf)b3=-g*math.cos(bf+math.pi/3)b9=-g*math.cos(bf-math.pi/3)ba=3 else local b7=math.sqrt(b6)local be=MathUtil.cuberoot(b7-b5)local a0=-MathUtil.cuberoot(b7+b5)b2=be+a0;ba=1 end;bb=1/3*a1;if ba>0 then b2=b2-bb end;if ba>1 then b3=b3-bb end;if ba>2 then b9=b9-bb end;return b2,b3,b9 end;function MathUtil.solveQuartic(b1,a7,a8,b8,bg)local b2,b3,b9,bh;local aM={}local bi,be,a0,bb;local a1,a2,a3,b6;local bc,b4,b5,bj;local ba=0;a1=a7/b1;a2=a8/b1;a3=b8/b1;b6=bg/b1;bc=a1*a1;b4=-0.375*bc+a2;b5=0.125*bc*a1-0.5*a1*a2+a3;bj=-(3/256)*bc*bc+0.0625*bc*a2-0.25*a1*a3+b6;if MathUtil.isZero(bj)then aM[3]=b5;aM[2]=b4;aM[1]=0;aM[0]=1;local bk={MathUtil.solveCubic(aM[0],aM[1],aM[2],aM[3])}ba=#bk;b2,b3,b9=bk[1],bk[2],bk[3]elseif MathUtil.isZero(b5)then local bl={MathUtil.solveQuadratic(1,b4,bj)}if bl[1]>=0 then b2=-math.sqrt(bl[1])b3=math.sqrt(bl[1])ba=2 end;if bl[2]>=0 then if ba==0 then b2=-math.sqrt(bl[2])b3=math.sqrt(bl[2])ba=2 else b9=-math.sqrt(bl[2])bh=math.sqrt(bl[2])ba=4 end end else aM[3]=0.5*bj*b4-0.125*b5*b5;aM[2]=-bj;aM[1]=-0.5*b4;aM[0]=1;b2,b3,b9=MathUtil.solveCubic(aM[0],aM[1],aM[2],aM[3])bi=b2;be=bi*bi-bj;a0=2*bi-b4;if MathUtil.isZero(be)then be=0 elseif be>0 then be=math.sqrt(be)else return end;if MathUtil.isZero(a0)then a0=0 elseif a0>0 then a0=math.sqrt(a0)else return end;aM[2]=bi-be;aM[1]=b5<0 and-a0 or a0;aM[0]=1;do local bk={MathUtil.solveQuadratic(aM[0],aM[1],aM[2])}ba=#bk;b2,b3=bk[1],bk[2]end;aM[2]=bi+be;aM[1]=b5<0 and a0 or-a0;aM[0]=1;if ba==0 then local bk={MathUtil.solveQuadratic(aM[0],aM[1],aM[2])}ba=ba+#bk;b2,b3=bk[1],bk[2]end;if ba==1 then local bk={MathUtil.solveQuadratic(aM[0],aM[1],aM[2])}ba=ba+#bk;b3,b9=bk[1],bk[2]end;if ba==2 then local bk={MathUtil.solveQuadratic(aM[0],aM[1],aM[2])}ba=ba+#bk;b9,bh=bk[1],bk[2]end end;bb=0.25*a1;if ba>0 then b2=b2-bb end;if ba>1 then b3=b3-bb end;if ba>2 then b9=b9-bb end;if ba>3 then bh=bh-bb end;return b2,b3,b9,bh end;function Matrix3.Matrix3(a_)local bm={}for F=1,9 do bm[F]=a_[F]end;setmetatable(bm,Matrix3.meta)return bm end;function Matrix3.get(bm,bn,bo)return bm[(bn-1)*3+bo]end;function Matrix3.set(bm,bn,bo,C)bm[(bn-1)*3+bo]=C end;function Matrix3.scalarmul(bm,s)local bp={}for F=1,9 do bp[F]=s*bm[F]end;return Matrix3.Matrix3(bp)end;function Matrix3.vecmul(bm,bq)local bp=Vector3.zero;for bn=1,3 do local C=0;for bo=1,3 do C=C+bq[bo]*bm[(bn-1)*3+bo]end;bp[bn]=C end;return bp end;function Matrix3.matmul(br,bs)local bp={}for F=1,3 do for Y=1,3 do local C=0;for _=1,3 do C=C+br[(F-1)*3+_]*bs[(_-1)*3+Y]end;bp[(F-1)*3+Y]=C end end;return Matrix3.Matrix3(bp)end;function Matrix3.mul(m,n)if getmetatable(m)~=Matrix3.meta then if type(m)==\"table\"and m.x then return Matrix3.vecmul(Matrix3.transpose(n),m)end;return Matrix3.mul(n,m)end;if getmetatable(n)==Matrix3.meta then return Matrix3.matmul(m,n)end;if type(n)==\"table\"and n.x then return Matrix3.vecmul(m,n)end;return Matrix3.scalarmul(m,n)end;function Matrix3.quadform(bt,bm,bu)return Vector3.Dot(bt,bm*bu)end;function Matrix3.Identity()return Matrix3.Matrix3({1,0,0,0,1,0,0,0,1})end;function Matrix3.Zero()return Matrix3.Matrix3({0,0,0,0,0,0,0,0,0})end;function Matrix3.pow(bm,bv)local bw=bm;local bx=bm;while true do bv=math.floor(bv/2)if bv%2==1 then bw=Matrix3.matmul(bm,bx)end;if bv>=2 then bx=Matrix3.matmul(bx,bx)else break end end;return bw end;function Matrix3.add(br,bs)local bp={}for F=1,9 do bp[F]=br[F]+bs[F]end;return Matrix3.Matrix3(bp)end;function Matrix3.hadamard(br,bs)local bp={}for F=1,9 do bp[F]=br[F]*bs[F]end;return Matrix3.Matrix3(bp)end;function Matrix3.transpose(bm)local by={}for bn=1,3 do for bo=1,3 do by[(bo-1)*3+bn]=bm[(bn-1)*3+bo]end end;return Matrix3.Matrix3(by)end;function Matrix3.determinant(bm)local bz=0;local bA=0;for h=1,3 do local bB=1;local bC=1;for s=1,3 do bB=bB*bm[(s-1)*3+(s+h-2)%3+1]bC=bC*bm[(s-1)*3+(-s+h)%3+1]end;bz=bz+bB;bA=bA+bC end;return bz-bA end;function Matrix3.adjugate(bm)local bD={}for bn=1,3 do for bo=1,3 do local bB=1;local bC=1;for F=1,2 do bB=bB*bm[(bn+F-1)%3*3+(bo+F-1)%3+1]bC=bC*bm[(bn+F-1)%3*3+(bo-F-1)%3+1]end;bD[(bo-1)*3+bn]=bB-bC end end;return Matrix3.Matrix3(bD)end;function Matrix3.inverse(bm)local bE=Matrix3.determinant(bm)if MathUtil.isZero(bE)then return end;local bD=Matrix3.adjugate(bm)return 1/bE*bD end;function Matrix3.tostring(bm)local bF=string.format(\"%f, %f, %f\\n%f, %f, %f\\n%f, %f, %f\",unpack(bm))return bF end;Matrix3.meta={__add=Matrix3.add,__mul=Matrix3.mul,__unm=function(bG)return Matrix3.scalarmul(bG,-1)end,__pow=Matrix3.pow,__tostring=Matrix3.tostring}function RingBuffer.RingBuffer(bH)local bI={}bI.buf={}bI.capacity=bH;bI.size=0;bI.head=1;local aX=getmetatable(bI)or{}aX.__index=RingBuffer.get;setmetatable(bI,aX)return bI end;function RingBuffer.isFull(bI)return bI.size>=bI.capacity end;function RingBuffer.push(bI,d)bI.buf[(bI.head+bI.size-1)%bI.capacity+1]=d;if bI.size==bI.capacity then bI.head=bI.head%bI.capacity+1 else bI.size=bI.size+1 end end;function RingBuffer.pop(bI)if bI.size==0 then return nil end;local C=bI.buf[bI.head]bI.buf[bI.head]=nil;bI.head=bI.head%bI.capacity+1;bI.size=bI.size-1;return C end;function RingBuffer.get(bI,p)if type(p)~=\"number\"or math.floor(p)~=p then return nil end;if p<1 or p>bI.size then return nil end;return bI.buf[(bI.head+p-2)%bI.capacity+1]end;function Search.interpolatedSearch(bJ,t,u,bK,bL,bM)bM=bM or 50;local m,n,bN;local bO=0;while u>t do m=bJ[t]if m==bK then return t end;if m>bK then return bL and t or nil end;n=bJ[u]if n==bK then return u end;if n<bK then return bL and u or nil end;bN=math.floor((bK-m)/(n-m)*(u-t)+t)bN=math.min(math.max(bN,t+1),u-1)if bJ[bN]==bK then return bN end;if bK<bJ[bN]then if bL and math.abs(bJ[bN-1]-bK)>math.abs(bJ[bN]-bK)then return bN end;u=bN-1 else if bL and math.abs(bJ[bN+1]-bK)>math.abs(bJ[bN]-bK)then return bN end;t=bN+1 end;bO=bO+1;if bO>bM then break end end;return bL and t or nil end;function Stats.Distribution(bP)local bQ={n=0,vars=bP}if bP then local bR={}local bS={}local bT=#bP;for F,a0 in ipairs(bP)do bR[a0]=0;for Y=1,bT do bS[(F-1)*bT+Y]=0 end end;bQ.mean=bR;bQ.cov=Matrix3.Matrix3(bS)else bQ.mean=0;bQ.cov=0 end;return bQ end;function Stats.updateDistribution(bQ,bU,bV)local bW=bQ.n;bV=bV or 1;bQ.n=bQ.n+bV;if bQ.vars then local bX={}local bT=bQ.vars and#bQ.vars or 1;for F,a0 in ipairs(bQ.vars)do bX[F]=bQ.mean[a0]local bY=bX[F]+bU[a0]*bV/bQ.n;for Y=F,bT do local ae=bQ.vars[Y]local bZ=bQ.mean[ae]local b_=(bV or 1)*(bU[a0]-bY)*(bU[ae]-bZ)bQ.cov[(F-1)*bT+Y]=(bQ.cov[(F-1)*bT+Y]*bW+b_)/bQ.n;bQ.cov[(Y-1)*bT+F]=bQ.cov[(F-1)*bT+Y]end;bQ.mean[a0]=bY end else local bY=bQ.mean+bU*bV/bQ.n;bQ.cov=(bQ.cov*bW+bV*(bU-bY)*(bU-bQ.mean))/bQ.n;bQ.mean=bY end end;function Stats.updateDistributionBatched(bQ,c0,c1)if#c0==0 then return end;local c2={}local bT=bQ.vars and#bQ.vars or 1;local c3=0;for Y=1,#c0 do c3=c3+(c1 and c1[Y]or 1)end;bQ.n=bQ.n+c3;local bW=bQ.n;if bQ.vars then for F,c4 in ipairs(bQ.vars)do local bo={}for Y=1,#c0 do bo[Y]=c0[Y][c4]end;c2[F]=bo end;for F,a0 in ipairs(bQ.vars)do local c5=0;for Y,s in ipairs(c2[F])do c5=c5+s*(c1 and c1[Y]or 1)end;local bY=bQ.mean[a0]+c5/bQ.n;for Y=F,bT do local bZ=bQ.mean[bQ.vars[Y]]c5=0;for s=1,#c0 do c5=c5+(c1 and c1[s]or 1)*(c2[F][s]-bY)*(c2[Y][s]-bZ)end;bQ.cov[(F-1)*bT+Y]=(bQ.cov[(F-1)*bT+Y]*bW+c5)/bQ.n;bQ.cov[(Y-1)*bT+F]=bQ.cov[(F-1)*bT+Y]end;bQ.mean[a0]=bY end else local c5=0;for F,s in ipairs(c0)do c5=c5+s*(c1 and c1[F]or 1)end;local bY=bQ.mean+c5/bQ.n;c5=0;for F,s in ipairs(c0)do c5=c5+(c1 and c1[F]or 1)*(s-bY)*(s-bQ.mean)end;bQ.cov=(bQ.cov*bW+c5)/bQ.n end end;function Stats.mean(bQ)return bQ.mean end;function Stats.covariance(bQ)return bQ.cov end;function Stats.namedCovariance(bQ,c6,c7)if not bQ.vars then return bQ.cov end;local bT=bQ.vars and#bQ.vars or 1;for F=1,bT do if bQ.vars[F]==c6 then for Y=1,bT do if bQ.vars[Y]==c7 then return bQ.cov[(F-1)*bT+Y]end end end end end;function Stats.normal()local bi,c8=Stats.boxMuller()return bi end;function Stats.normalPDF(bi)return math.exp(-0.5*bi*bi)/math.sqrt(2*math.pi)end;function Stats.normalCDF(bi)local c9=0.2316419;local ca=0.319381530;local cb=-0.356563782;local cc=1.781477937;local cd=-1.821255978;local ce=1.330274429;local g=1/(1+c9*bi)return 1-Stats.normalPDF(bi)*(ca*g+cb*g^2+cc*g^3+cd*g^4+ce*g^5)end;function Stats.inverseNorm(b4)local cf=b4>=0.5 and b4 or-b4;local bi=5.55556*(1-((1-cf)/cf)^0.1186)if b4<0.5 then bi=-bi end;return bi end;function Stats.boxMuller()local cg=math.random()local ch=math.random()ch=math.random()ch=math.random()local bj=math.sqrt(-2*math.log(cg))local ci=2*math.pi*ch;return bj*math.cos(ci),bj*math.sin(ci)end;VectorN.mt=getmetatable({})or{}VectorN.mt.__add=function(m,n)local cj=type(m)==\"number\"local ck=type(n)==\"number\"if not cj and ck then return n+m end;if cj and not ck then return Stats.combine(m,n,function(_,ao,cl)return m+cl end)else return Stats.combine(m,n,function(_,ao,cl)return ao+cl end)end end;VectorN.mt.__sub=function(m,n)return m+-n end;VectorN.mt.__mul=function(m,n)local cj=type(m)==\"number\"local ck=type(n)==\"number\"if not cj and ck then return n*m end;if cj and not ck then local z={}for _,a0 in pairs(n)do z[_]=m*a0 end;return z else return Stats.combine(m,n,function(_,ao,cl)return ao*cl end)end end;VectorN.mt.__div=function(m,n)local cj=type(m)==\"number\"local ck=type(n)==\"number\"if not cj and ck then return m*1/n end;if cj and not ck then local z={}for _,a0 in pairs(n)do z[_]=m/a0 end;return z else return Stats.combine(m,n,function(_,ao,cl)return ao/cl end)end end;VectorN.mt.__unm=function(m)local z={}for _,a0 in pairs(m)do z[_]=-a0 end;return z end;function VectorN.VectorN(B)local bq={}for _,a0 in pairs(B)do if type(a0)==\"table\"then bq[_]=VectorN.VectorN(a0)else bq[_]=a0 end end;setmetatable(bq,VectorN.mt)return bq end;function Control.PID(cm,cn,co,cp,cq,cr)local cs={}cs.kP=cm;cs.kI=cn;cs.kD=co;cs.Iacc=Accumulator.Accumulator(cp,cq)if cr and cr~=0 then cs.period=cr end;return cs end;function Control.processPID(ct,cu,e)cu=ct.period and(cu+ct.period/2)%ct.period-ct.period/2 or cu;local b4=ct.kP*cu;local F,cv=Accumulator.update(ct.Iacc,cu,e)F=ct.kI*F/cv;local h=ct.kD*(cu-(ct.lastError or cu))/e;ct.lastError=cu;return b4+F+h end;function Control.FF(aM,cr)local cw={}cw.coeffs=aM;cw.degree=#aM-1;if cr and cr~=0 then cw.period=cr end;cw.derivs={}return cw end;function Control.processFF(ct,bK,e)local cx=0*bK;local cy=bK;local cz=bK;for F=1,ct.degree+1 do cz=ct.derivs[F]ct.derivs[F]=cy;cx=cx+ct.coeffs[F]*cy;if cz then local aD=cy-cz;if F==1 and ct.period then aD=(aD+ct.period/2)%ct.period-ct.period/2 end;cy=aD/e else break end end;return cx end;function Nav.toLocal(cA,cB,cC)local cD=cA-cB;return Quaternion.Inverse(cC)*cD end;function Nav.toGlobal(cE,cB,cC)local cD=cC*cE;return cD+cB end;function Nav.cartToPol(cF)local bj=cF.magnitude;local ci=Vector3.SignedAngle(Vector3.forward,cF,Vector3.up)local bf=90-Vector3.Angle(Vector3.up,cF)return Vector3(bj,ci,bf)end;function Nav.cartToCyl(cF)local cG=Vector3(cF.x,0,cF.z)local cH=cG.magnitude;local bf=Vector3.SignedAngle(Vector3.forward,cF,Vector3.up)local bi=cF.y;return Vector3(cH,bf,bi)end;function Nav.polToCart(cF)local bj,ci,bf=cF.x,cF.y,cF.z;local ao=Mathf.Sin(ci)*Mathf.Cos(bf)local cl=Mathf.Sin(bf)local bi=Mathf.Cos(ci)*Mathf.Cos(bf)return bj*Vector3(ao,cl,bi)end;function Nav.cylToCart(cF)local cH,bf,cI=cF.x,cF.y,cF.z;local ao=cH*Mathf.Sin(bf)local cl=cI;local bi=cH*Mathf.Cos(bf)return Vector3(ao,cl,bi)end;function Targeting.firstOrderTargeting(cJ,cK,cL)if cK.sqrMagnitude==0 then return cJ.normalized end;local cM=cJ-Vector3.Project(cJ,cK)local cN=Vector3.Dot(cK,cJ-cM)/cK.sqrMagnitude;local m,n=MathUtil.solveQuadratic(cK.sqrMagnitude-cL*cL,2*cN*cK.sqrMagnitude,cM.sqrMagnitude+cN*cN*cK.sqrMagnitude)local cO=nil;if m and m>=0 then cO=m end;if n and n>=0 and n<m then cO=n end;if cO then return cJ+cO*cK,cO end end;function Targeting.secondOrderTargetingNewton(cJ,cP,cQ,cL,cR,cS,ak)local aD=10000;local cT=0;local aq=0;if not ak then ak=0 end;local cU=cJ+ak*cP+0.5*ak*ak*cQ;while math.abs(aD)>0.001 and aq<10 do local g=cU.magnitude/cL;aD=g-cT;cT=g;aq=aq+1;cU=cJ+g*cP+0.5*g*g*cQ end;return cU,cT,aq end;Targeting.secondOrderTargeting=Targeting.secondOrderTargetingNewton;function Targeting.secondOrderTargetingITP(cJ,cP,cQ,cL,cR,cS,ak)if not ak then ak=0 end;local m=-0.25*cQ.sqrMagnitude;local n=-Vector3.Dot(cP,cQ)local Q=-(cP.sqrMagnitude-cL*cL+Vector3.Dot(cJ,cQ))local h=-2*Vector3.Dot(cJ,cP)local cu=-cJ.sqrMagnitude;local g;local cV=cQ.magnitude;local cW=cP.magnitude;local cX=cJ.magnitude;local cY,cZ=MathUtil.solveQuadratic(0.5*cV,cW+cL,-cX)local c_=math.max(cY,cZ)local d0;local aM={0.5*cV,cW-cL,cX}if MathUtil.ruleOfSigns(aM,0)==2 then local d1,d2=MathUtil.solveQuadratic(aM[1],aM[2],aM[3])if d1 then d0=math.min(d1,d2)end end;if not d0 or d0<c_ then local b2,b3,b9=MathUtil.solveCubic(4*m,3*n,2*Q,h)if not b9 then if b2>c_ then d0=b2 end else local d1=math.min(b2,b9)local d2=math.max(b2,b9)if d1>c_ then d0=d1 elseif d2>c_ then d0=d2 end end;if not d0 then return end end;local function d3(ao)return cu+ao*(h+ao*(Q+ao*(n+ao*m)))end;if ak>c_ and d0>ak then if d3(c_)*d3(g)<0 then d0=ak else c_=ak end end;g=MathUtil.ITP(d3,c_,d0,1e-4,25)if not g then return end;if g>=c_ and g<=d0 then local d4=cJ+cP*g+0.5*cQ*g*g;if d4.magnitude>=cR and d4.magnitude<=cS then return d4,g end end end;function Targeting.AIPPN(d5,cJ,d6,cK,d7)local cP=cK-d6;local d8=Vector3.Dot(-cP,cJ.normalized)if d8<=0 then d8=10 end;local d9=cJ.magnitude/d8;local da=Vector3.Cross(cJ,cP)/cJ.sqrMagnitude;local db=Vector3.Cross(cJ,d7)/cJ.sqrMagnitude*d9/2;local dc=da+db;local dd=Vector3.Cross(dc,cJ.normalized)local de=Vector3.ProjectOnPlane(dd,d6).normalized;local df=d5*d6.magnitude*dc.magnitude;return df*de end;function Targeting.ATPN(d5,cJ,d6,cK,d7)local cP=cK-d6;local d8=-Vector3.Dot(cP,cJ.normalized)if d8<=0 then d8=10 end;local da=Vector3.Cross(cJ,cP)/cJ.sqrMagnitude;local dd=Vector3.Cross(da,cJ.normalized)local dg=Vector3.ProjectOnPlane(d7,cJ)return d5*d8*dd+0.5*d5*d7 end;function BlockUtil.getWeaponsByName(dh,di,aW,dj)if DEBUG then dh:Log(\"searching for \"..di)end;local dk={}aW=aW or-1;local Q=aW;if not dj or dj==0 or dj==2 then for F=0,dh:GetWeaponCount()-1 do if Q==0 then break end;if dh:GetWeaponBlockInfo(F).CustomName==di then table.insert(dk,{subIdx=nil,wpnIdx=F})if DEBUG then dh:Log(\"found weapon \"..di..\" on hull, type \"..dh:GetWeaponInfo(F).WeaponType)end;Q=Q-1 end end end;if not dj or dj==1 or dj==2 then local dl=dh:GetAllSubConstructs()for p=1,#dl do local bb=dl[p]for F=0,dh:GetWeaponCountOnSubConstruct(bb)-1 do if Q==0 then break end;if dh:GetWeaponBlockInfoOnSubConstruct(bb,F).CustomName==di then table.insert(dk,{subIdx=bb,wpnIdx=F})if DEBUG then dh:Log(\"found weapon \"..di..\" on subobj \"..bb..\", type \"..dh:GetWeaponInfoOnSubConstruct(bb,F).WeaponType)end;Q=Q-1 end end end end;if DEBUG then dh:Log(\"weapon count: \"..#dk)end;return dk end;function BlockUtil.getSubConstructsByName(dh,di,aW)if DEBUG then dh:Log(\"searching for \"..di)end;local dl=dh:GetAllSubConstructs()local dm={}aW=aW or-1;local Q=aW;for p=1,#dl do local bb=dl[p]if Q==0 then break end;if dh:GetSubConstructInfo(bb).CustomName==di then table.insert(dm,bb)if DEBUG then dh:Log(\"found subobj \"..di)end;Q=Q-1 end end;if DEBUG then dh:Log(\"subobj count: \"..#dm)end;return dm end;function BlockUtil.getBlocksByName(dh,di,dn,aW)if DEBUG then dh:Log(\"searching for \"..di)end;local dp={}aW=aW or-1;local Q=aW;for p=0,dh:Component_GetCount(dn)-1 do if Q==0 then break end;if dh:Component_GetBlockInfo(dn,p).CustomName==di then table.insert(dp,p)if DEBUG then dh:Log(\"found component \"..di)end;Q=Q-1 end end;if DEBUG then dh:Log(\"component count: \"..#dp)end;return dp end;function BlockUtil.populateWeaponsByName(dh,dj)if DEBUG then dh:Log(\"populating all weapons, mode \"..dj)end;local dk={}for p=0,dh:GetWeaponCount()-1 do local di=dh:Component_GetBlockInfo(type,p).CustomName;if di and di~=''then dk[di]=dk[di]or{}table.insert(dk[di],{subIdx=nil,wpnIdx=p})if DEBUG then dh:Log(\"found weapon \"..di..\" on hull, type \"..dh:GetWeaponInfo(p).WeaponType)end else table.insert(dk,{subIdx=nil,wpnIdx=p})if DEBUG then dh:Log(\"found unnamed weapon on hull, type \"..dh:GetWeaponInfo(p).WeaponType)end end end;if not dj or dj==1 or dj==2 then local dl=dh:GetAllSubConstructs()for p=1,#dl do local bb=dl[p]for F=0,dh:GetWeaponCountOnSubConstruct(bb)-1 do local di=dh:Component_GetBlockInfo(type,F).CustomName;if di and di~=''then dk[di]=dk[di]or{}table.insert(dk[di],{subIdx=bb,wpnIdx=F})if DEBUG then dh:Log(\"found weapon \"..di..\" on subobj \"..bb..\", type \"..dh:GetWeaponInfoOnSubConstruct(bb,F).WeaponType)end else table.insert(dk,{subIdx=bb,wpnIdx=F})if DEBUG then dh:Log(\"found unnamed weapon on subobj \"..bb..\", type \"..dh:GetWeaponInfoOnSubConstruct(bb,F).WeaponType)end end end end end;if DEBUG then local aW=0;for _,a0 in pairs(dk)do if type(a0)==\"table\"then aW=aW+#a0 else aW=aW+1 end end;dh:Log(\"weapon count: \"..aW)end;return dk end;function BlockUtil.populateSubConstructsByName(dh)if DEBUG then dh:Log(\"populating all subconstructs\")end;local dl=dh:GetAllSubConstructs()local dm={}for p=1,#dl do local bb=dl[p]local di=dh:GetSubConstructInfo(bb).CustomName;if di and di~=''then dm[di]=dm[di]or{}table.insert(dm[di],bb)if DEBUG then dh:Log(\"found subobj \"..di)end else table.insert(dm,bb)if DEBUG then dh:Log(\"found unnamed subobj\")end end end;if DEBUG then local aW=0;for _,a0 in pairs(dm)do if type(a0)==\"table\"then aW=aW+#a0 else aW=aW+1 end end;dh:Log(\"subobject count: \"..aW)end;return dm end;function BlockUtil.populateBlocksByName(dh,dn)if DEBUG then dh:Log(\"populating all blocks of type \"..dn)end;local dp={}for p=0,dh:Component_GetCount(dn)-1 do local di=dh:Component_GetBlockInfo(dn,p).CustomName;if di and di~=''then dp[di]=dp[di]or{}table.insert(dp[di],p)if DEBUG then dh:Log(\"found component \"..di)end else table.insert(dp,p)if DEBUG then dh:Log(\"found unnamed component of type \"..dn)end end end;if DEBUG then local aW=0;for _,a0 in pairs(dp)do if type(a0)==\"table\"then aW=aW+#a0 else aW=aW+1 end end;dh:Log(\"component count: \"..aW)end;return dp end;function BlockUtil.getWeaponInfo(dh,dq)if dq.subIdx then return dh:GetWeaponInfoOnSubConstruct(dq.subIdx,dq.wpnIdx)end;return dh:GetWeaponInfo(dq.wpnIdx)end;function BlockUtil.getWeaponBlockInfo(dh,dq)if dq.subIdx then return dh:GetWeaponBlockInfoOnSubConstruct(dq.subIdx,dq.wpnIdx)end;return dh:GetWeaponBlockInfo(dq.wpnIdx)end;function BlockUtil.aimWeapon(dh,dq,dr,ds)if dq.subIdx then dh:AimWeaponInDirectionOnSubConstruct(dq.subIdx,dq.wpnIdx,dr.x,dr.y,dr.z,ds)else dh:AimWeaponInDirection(dq.wpnIdx,dr.x,dr.y,dr.z,ds)end end;function BlockUtil.fireWeapon(dh,dq,ds)if dq.subIdx then return dh:FireWeaponOnSubConstruct(dq.subIdx,dq.wpnIdx,ds)end;return dh:FireWeapon(dq.wpnIdx,ds)end;function Combat.pickTarget(dh,dt,du)du=du or function(U,dv)return dv.Priority end;local bK,dw;for F in MathUtil.range(dh:GetNumberOfTargets(dt))do local dv=dh:GetTargetInfo(dt,F)local dx=du(dh,dv)if not bK or dx>dw then bK=dv;dw=dx end end;return bK end;function Combat.CheckConstraints(dh,dy,dz,dA)local dB;if dA then dB=dh:GetWeaponConstraintsOnSubConstruct(dA,dz)else dB=dh:GetWeaponConstraints(dz)end;if not dB or not dB.Valid then return true end;local dC=dh:GetConstructForwardVector()local dD=dh:GetConstructUpVector()local dE=Quaternion.LookRotation(dC,dD)dy=Quaternion.Inverse(dE)*dy;if dB.InParentConstructSpace and dA then local dF=dh:GetSubConstructInfo(dA).localRotation;dy=Quaternion.inverse(dF)*dy end;local dG=MathUtil.angleOnPlane(Vector3.forward,dy,Vector3.up)local dH=dy;dH.y=0;local O=Mathf.Atan2(dy.y,dH.magnitude)local dI=dG>dB.MinAzimuth and dG<dB.MaxAzimuth;local dJ=O>dB.MinElevation and O<dB.MaxElevation;if dB.FlipAzimuth then dI=not dI end;if dI and dJ then return true end;dG=dG+180;O=180-O;if O>180 then O=O-360 end;if O<-180 then O=O+360 end;dI=dG>dB.MinAzimuth and dG<dB.MaxAzimuth;dJ=O>dB.MinElevation and O<dB.MaxElevation;if dB.FlipAzimuth then dI=not dI end;if dI and dJ then return true end;return false end;function StringUtil.LogVector(dh,bq,dK)dh:Log(dK..\"(\"..bq.x..\", \"..bq.y..\", \"..bq.z..\")\")end\r\n"],"BlockStringDataIds":[41],"GameVersion":"4.1.2.0","PersistentSubObjectIndex":8,"PersistentBlockIndex":116,"AuthorDetails":{"Valid":true,"ForeignBlocks":276,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"fe5bb7da-f3e9-4d92-acd2-f7002e9544b0","CreatorReadableName":"DreekFire","HashV1":"869bf8b6ab4ad3e04b48c270a0042256"},"BlockCount":924}}